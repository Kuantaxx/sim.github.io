<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K√ºresel Aynalar Sim√ºlasyonu</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --panel-bg: rgba(20, 24, 32, 0.95);
            --accent-color: #00f2fe;
            --text-color: #e0e0e0;
        }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color); color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex; flex-direction: column; 
            height: 100vh; height: 100dvh; 
            overflow: hidden; touch-action: none;
        }
        #top-bar {
            display: flex; flex-wrap: wrap; gap: 8px; padding: 10px 15px;
            background: var(--panel-bg); width: 100%; box-sizing: border-box;
            align-items: center; justify-content: center;
            border-bottom: 1px solid #333; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 10; flex-shrink: 0; 
        }
        .control-group { display: flex; gap: 6px; align-items: center; padding: 5px 10px; background: rgba(255,255,255,0.05); border-radius: 8px; }
        .separator { width: 1px; height: 30px; background: #444; margin: 0 2px; }
        
        button {
            padding: 6px 10px; font-size: 13px; font-weight: 600; cursor: pointer;
            background-color: transparent; color: #888;
            border: 1px solid transparent; border-radius: 6px; transition: 0.3s;
        }
        button:hover { color: var(--text-color); background: rgba(255,255,255,0.1); }
        button.mode-btn.active { background-color: var(--accent-color); color: #000; box-shadow: 0 0 10px rgba(0, 242, 254, 0.3); }
        button.mirror-btn.active { border-color: var(--accent-color); color: var(--accent-color); }
        button.shape-btn.active { background-color: rgba(57, 255, 20, 0.2); color: #39ff14; border-color: #39ff14; }

        label { font-size: 12px; font-weight: 600; color: #aaa; cursor: pointer; display: flex; align-items: center; gap: 4px; white-space: nowrap;}
        input[type="range"] { cursor: pointer; width: 70px; accent-color: var(--accent-color); }
        input[type="checkbox"] { accent-color: var(--accent-color); cursor: pointer; margin: 0; }
        
        #canvas-wrapper { flex: 1; position: relative; width: 100%; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: crosshair; background-color: #05070a; background-image: linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px); background-size: 50px 50px; }

        #info-overlay {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(12, 16, 22, 0.85); padding: 8px 15px; border-radius: 8px;
            border: 1px solid #333; border-left: 4px solid var(--accent-color);
            pointer-events: none; user-select: none; backdrop-filter: blur(8px); 
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); font-size: 13px; z-index: 5;
            display: flex; align-items: center; gap: 12px; flex-wrap: wrap; max-width: calc(100% - 40px); 
        }
        .info-section { display: flex; align-items: center; gap: 6px; }
        .info-divider { width: 1px; height: 14px; background: #444; }
        
        body.mode-isin #shape-controls { display: none; }

        @media (max-width: 1000px) {
            #info-overlay { bottom: 10px; left: 10px; right: 10px; font-size: 11px; padding: 8px 10px; gap: 8px; }
            .separator { display: none; }
            #top-bar { padding: 5px; gap: 4px; justify-content: flex-start; overflow-x: auto; }
            .control-group { padding: 4px 6px; flex-shrink: 0; }
        }

        .hl { font-weight: bold; color: #00f2fe; }
        .hl-obj { font-weight: bold; color: #39ff14; }
        .hl-img { font-weight: bold; color: #ffbd00; }
    </style>
</head>
<body class="mode-isin">

    <div id="top-bar">
        <div class="control-group">
            <button id="btnModeIsin" class="mode-btn active">I≈üƒ±n Modu üî¶</button>
            <button id="btnModeGoruntu" class="mode-btn">G√∂r√ºnt√º Modu üïØÔ∏è</button>
        </div>
        
        <div id="shape-controls" class="control-group" style="border-color: #39ff14;">
            <button id="btnShapeArrow" class="shape-btn active">Ok ‚¨ÜÔ∏è</button>
            <button id="btnShapeTriangle" class="shape-btn">√ú√ßgen üî∫</button>
            <button id="btnShapeF" class="shape-btn">F Harfi ‚íª</button>
        </div>

        <div class="separator"></div>
        <div class="control-group">
            <button id="btnCukur" class="mirror-btn active">√áukur</button>
            <button id="btnTumsek" class="mirror-btn">T√ºmsek</button>
        </div>
        <div class="separator"></div>
        <div class="control-group">
             <label><input type="checkbox" id="checkAxis"> Asal Eksen</label>
             <label><input type="checkbox" id="checkT"> Tepe noktasƒ± (T)</label>
             <label><input type="checkbox" id="checkF"> Odak noktasƒ± (f)</label>
             <label><input type="checkbox" id="checkM"> Merkez noktasƒ± (M)</label>
        </div>
        <div class="control-group">
             <label><input type="checkbox" id="checkNormal"> Y√ºzey Normali</label>
             <label><input type="checkbox" id="checkRuler" checked> Cetvel</label>
        </div>
        <div class="control-group" style="margin-left:auto;">
            <label for="sliderR">R:<span id="valR" style="color:#00f2fe; width:25px; text-align:center;">400</span></label>
            <input type="range" id="sliderR" min="200" max="600" value="400" step="50">
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="simCanvas"></canvas>
        <div id="info-overlay">Y√ºkleniyor...</div>
    </div>

<script>
    const wrapper = document.getElementById('canvas-wrapper');
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const infoOverlay = document.getElementById('info-overlay');
    
    const btnModeIsin = document.getElementById('btnModeIsin');
    const btnModeGoruntu = document.getElementById('btnModeGoruntu');
    const btnCukur = document.getElementById('btnCukur');
    const btnTumsek = document.getElementById('btnTumsek');
    
    const btnShapeArrow = document.getElementById('btnShapeArrow');
    const btnShapeTriangle = document.getElementById('btnShapeTriangle');
    const btnShapeF = document.getElementById('btnShapeF');

    const checkAxis = document.getElementById('checkAxis');
    const checkT = document.getElementById('checkT');
    const checkF = document.getElementById('checkF');
    const checkM = document.getElementById('checkM');
    const checkNormal = document.getElementById('checkNormal');
    const checkRuler = document.getElementById('checkRuler');
    const sliderR = document.getElementById('sliderR');
    const valR = document.getElementById('valR');

    const C_ACCENT = '#00f2fe';
    const C_LASER = '#ff0055';
    const C_OBJ = '#39ff14';
    const C_IMG = '#ffbd00';

    let width, height;
    let currentMode = 'isin';
    let mirrorType = 'cukur'; 
    let currentShape = 'arrow'; 
    let R = 400; let F = R / 2;
    
    let showAxis = false; let showT = false; let showF = false; let showM = false;
    let showNormal = false; let showRuler = true;
    
    let laser = { x: 100, y: 300, angle: 0, isDraggingBody: false, isDraggingTip: false };
    let obj = { x: 150, isDragging: false }; 
    let ruler = { x: -1000, y: -1000, w: 400, h: 40, isDragging: false, offX: 0, offY: 0 }; 

    const shapesDefinition = {
        arrow: [
            {x1:0, y1:0, x2:0, y2:-80, isTip: true, hasArrowHead: true} 
        ],
        triangle: [
            {x1:0, y1:0, x2:60, y2:0}, 
            {x1:0, y1:0, x2:30, y2:-70, isTip: true}, 
            {x1:60, y1:0, x2:30, y2:-70} 
        ],
        letterF: [
            {x1:0, y1:0, x2:0, y2:-80, isTip: true}, 
            {x1:0, y1:-80, x2:40, y2:-80}, 
            {x1:0, y1:-40, x2:30, y2:-40}  
        ]
    };

    function resize() {
        width = wrapper.clientWidth; height = wrapper.clientHeight;
        canvas.width = width; canvas.height = height;
        if (laser.y > height) laser.y = height / 2 + 50; 
        if (ruler.x === -1000) { ruler.x = width / 2 - 200; ruler.y = height - 100; }
        draw();
    }
    window.addEventListener('resize', resize);

    btnModeIsin.onclick = () => setMode('isin');
    btnModeGoruntu.onclick = () => setMode('goruntu');
    btnCukur.onclick = () => setMirror('cukur');
    btnTumsek.onclick = () => setMirror('tumsek');
    
    btnShapeArrow.onclick = () => setShape('arrow');
    btnShapeTriangle.onclick = () => setShape('triangle');
    btnShapeF.onclick = () => setShape('letterF');

    checkAxis.onchange = (e) => { showAxis = e.target.checked; draw(); };
    checkT.onchange = (e) => { showT = e.target.checked; draw(); };
    checkF.onchange = (e) => { showF = e.target.checked; draw(); };
    checkM.onchange = (e) => { showM = e.target.checked; draw(); };
    checkNormal.onchange = (e) => { showNormal = e.target.checked; draw(); };
    checkRuler.onchange = (e) => { showRuler = e.target.checked; draw(); };
    sliderR.oninput = (e) => { R = parseInt(e.target.value); F = R / 2; valR.innerText = R; draw(); };

    function setMode(mode) {
        currentMode = mode;
        document.body.className = 'mode-' + mode; 
        btnModeIsin.classList.toggle('active', mode === 'isin');
        btnModeGoruntu.classList.toggle('active', mode === 'goruntu');
        draw();
    }
    function setMirror(type) {
        mirrorType = type;
        btnCukur.classList.toggle('active', type === 'cukur');
        btnTumsek.classList.toggle('active', type === 'tumsek');
        draw();
    }
    function setShape(shape) {
        currentShape = shape;
        btnShapeArrow.classList.toggle('active', shape === 'arrow');
        btnShapeTriangle.classList.toggle('active', shape === 'triangle');
        btnShapeF.classList.toggle('active', shape === 'letterF');
        draw();
    }

    function handleStart(e) {
        if(e.type === 'touchstart') e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const mx = clientX - rect.left; const my = clientY - rect.top;
        const centerY = height / 2;

        if (showRuler && mx >= ruler.x && mx <= ruler.x + ruler.w && my >= ruler.y && my <= ruler.y + ruler.h) {
            ruler.isDragging = true; ruler.offX = mx - ruler.x; ruler.offY = my - ruler.y; return;
        }

        if (currentMode === 'isin') {
            let tipX = laser.x + Math.cos(laser.angle) * 55; let tipY = laser.y + Math.sin(laser.angle) * 55;
            if (Math.hypot(mx - tipX, my - tipY) < 35) { laser.isDraggingTip = true; return; }
            if (Math.hypot(mx - laser.x, my - laser.y) < 50) { laser.isDraggingBody = true; return; }
        } else {
            if (Math.abs(mx - obj.x) < 50 && my > centerY - 100 && my < centerY + 20) {
                obj.isDragging = true; return;
            }
        }
    }

    function handleMove(e) {
        if(e.type === 'touchmove') e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const mx = clientX - rect.left; const my = clientY - rect.top;
        const centerY = height / 2;

        if (ruler.isDragging) { ruler.x = mx - ruler.offX; ruler.y = my - ruler.offY; draw(); canvas.style.cursor = 'grabbing'; return; }
        if (laser.isDraggingBody) { laser.x = mx; laser.y = my; draw(); canvas.style.cursor = 'grabbing'; return; }
        if (laser.isDraggingTip) { laser.angle = Math.atan2(my - laser.y, mx - laser.x); draw(); canvas.style.cursor = 'grabbing'; return; }
        if (obj.isDragging) {
            let limitX = width / 2 + (width > 600 ? 80 : 30); 
            obj.x = Math.min(mx, limitX); draw(); canvas.style.cursor = 'grabbing'; return;
        }

        let isHovering = false;
        if (showRuler && mx >= ruler.x && mx <= ruler.x + ruler.w && my >= ruler.y && my <= ruler.y + ruler.h) isHovering = true;
        
        if (!isHovering) {
            if (currentMode === 'isin') {
                let tipX = laser.x + Math.cos(laser.angle) * 55; let tipY = laser.y + Math.sin(laser.angle) * 55;
                if (Math.hypot(mx - tipX, my - tipY) < 35 || Math.hypot(mx - laser.x, my - laser.y) < 50) isHovering = true;
            } else {
                if (Math.abs(mx - obj.x) < 50 && my > centerY - 100 && my < centerY + 20) isHovering = true;
            }
        }
        canvas.style.cursor = isHovering ? 'grab' : 'crosshair';
    }

    const stopDrag = () => { ruler.isDragging = false; laser.isDraggingBody = false; laser.isDraggingTip = false; obj.isDragging = false; canvas.style.cursor = 'crosshair'; };

    canvas.addEventListener('mousedown', handleStart); canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', stopDrag); canvas.addEventListener('mouseleave', stopDrag);
    canvas.addEventListener('touchstart', handleStart, {passive: false}); canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', stopDrag);

    // --- √áƒ∞Zƒ∞M MOTORU ---
    function draw() {
        ctx.clearRect(0, 0, width, height);
        const centerY = height / 2;
        const centerX = width > 600 ? width / 2 + 100 : width / 2 + 50; 
        
        let T_x = centerX;
        let M_x = mirrorType === 'cukur' ? T_x - R : T_x + R;
        let F_x = mirrorType === 'cukur' ? T_x - F : T_x + F;

        drawAxis(centerY, T_x);
        drawMirror(centerY, R, M_x); 

        if (currentMode === 'isin') {
            drawModernLaser();
            calculateAndDrawRay(M_x, centerY, F_x, R);
            updateInfoRayMode();
        } else {
            drawComplexShapeMode(centerY, T_x, F_x, M_x);
        }
        
        drawPoints(centerY, T_x, F_x, M_x);
        drawPortableRuler();
    }

    function drawNormal(M_x, centerY, ix, iy) {
        let nAngle = Math.atan2(iy - centerY, ix - M_x);
        drawDashedLine(M_x, centerY, ix + Math.cos(nAngle)*100, iy + Math.sin(nAngle)*100, 'rgba(0, 242, 254, 0.4)');
    }

    function calculateImagePoint(objX, objY, centerY, T_x, F_val) {
        let d_o = T_x - objX; 
        if (Math.abs(d_o - F_val) < 0.5) return null;
        let d_i = (d_o * F_val) / (d_o - F_val);
        let m = -d_i / d_o; 
        let imgX = T_x - d_i;
        let h_o = centerY - objY; 
        let h_i = h_o * m; 
        let imgY = centerY - h_i;
        return { x: imgX, y: imgY, d_i: d_i, m: m };
    }

    function drawComplexShapeMode(centerY, T_x, F_x, M_x) {
        let f_val = mirrorType === 'cukur' ? F : -F;
        let shapeSegments = shapesDefinition[currentShape];
        let tipPointObj = null; 
        let mainImageInfo = null; 

        // Cƒ∞Sƒ∞M √áƒ∞Zƒ∞Mƒ∞
        ctx.strokeStyle = C_OBJ; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath();
        let objArrowHeads = [];
        shapeSegments.forEach(seg => {
            let absX1 = obj.x + seg.x1; let absY1 = centerY + seg.y1;
            let absX2 = obj.x + seg.x2; let absY2 = centerY + seg.y2;
            ctx.moveTo(absX1, absY1); ctx.lineTo(absX2, absY2);
            if(seg.isTip && seg.hasArrowHead) objArrowHeads.push({x1: absX1, y1: absY1, x2: absX2, y2: absY2});
            if(seg.isTip) tipPointObj = {x: absX2, y: absY2}; 
        });
        ctx.stroke(); 
        
        objArrowHeads.forEach(ah => {
            ctx.fillStyle = C_OBJ; ctx.strokeStyle = C_OBJ;
            drawArrowHead(ah.x1, ah.y1, ah.x2, ah.y2);
        });
        
        ctx.fillStyle = C_OBJ; ctx.font = 'bold 14px Segoe UI'; 
        ctx.fillText(currentShape === 'arrow' ? 'Cisim' : '', obj.x - 20, centerY + 30);

        // G√ñR√úNT√ú √áƒ∞Zƒ∞Mƒ∞
        let isVirtual = false;
        let imgArrowHeads = [];
        ctx.beginPath();
        shapeSegments.forEach(seg => {
            let p1_img = calculateImagePoint(obj.x + seg.x1, centerY + seg.y1, centerY, T_x, f_val);
            let p2_img = calculateImagePoint(obj.x + seg.x2, centerY + seg.y2, centerY, T_x, f_val);

            if (p1_img && p2_img) {
                ctx.moveTo(p1_img.x, p1_img.y); ctx.lineTo(p2_img.x, p2_img.y);
                if (p1_img.d_i < 0) isVirtual = true; 
                if (seg.isTip) {
                    mainImageInfo = p2_img; 
                    if(seg.hasArrowHead) imgArrowHeads.push({x1: p1_img.x, y1: p1_img.y, x2: p2_img.x, y2: p2_img.y});
                }
            }
        });

        ctx.strokeStyle = C_IMG; 
        if (isVirtual) ctx.setLineDash([8, 5]); 
        ctx.stroke(); 
        ctx.setLineDash([]); 

        imgArrowHeads.forEach(ah => {
            ctx.fillStyle = C_IMG; ctx.strokeStyle = C_IMG;
            drawArrowHead(ah.x1, ah.y1, ah.x2, ah.y2);
        });

        // I≈ûINLAR
        if (tipPointObj && mainImageInfo) {
            drawPrincipalRays(tipPointObj.x, tipPointObj.y, mainImageInfo.x, mainImageInfo.y, centerY, T_x, F_x);
        }

        let d_o_main = T_x - obj.x;
        updateInfoImageMode(d_o_main, mainImageInfo ? mainImageInfo.d_i : null, mainImageInfo ? mainImageInfo.m : null);
    }
    
    function drawArrowHead(x1, y1, x2, y2) {
        let angle = Math.atan2(y2-y1, x2-x1); let head = 14;
        ctx.save(); ctx.beginPath(); ctx.moveTo(x2, y2);
        ctx.lineTo(x2-head*Math.cos(angle-Math.PI/6), y2-head*Math.sin(angle-Math.PI/6));
        ctx.lineTo(x2-head*Math.cos(angle+Math.PI/6), y2-head*Math.sin(angle+Math.PI/6));
        ctx.closePath(); ctx.fill(); ctx.restore();
    }

    function drawPrincipalRays(objX, objY, imgX, imgY, centerY, T_x, F_x) {
        ctx.lineWidth = 2; 
        ctx.strokeStyle = 'rgba(255, 50, 100, 0.5)'; ctx.beginPath(); ctx.moveTo(objX, objY); ctx.lineTo(T_x, objY); ctx.stroke();
        if (mirrorType === 'cukur') {
             let vX = F_x - T_x, vY = centerY - objY;
             ctx.beginPath(); ctx.moveTo(T_x, objY); ctx.lineTo(T_x + vX*5, objY + vY*5); ctx.stroke();
             if(imgX > T_x) drawDashedLine(T_x, objY, imgX, imgY, 'rgba(255, 50, 100, 0.3)'); 
        } else {
             let vX = T_x - F_x, vY = objY - centerY;
             ctx.beginPath(); ctx.moveTo(T_x, objY); ctx.lineTo(T_x + vX*5, objY + vY*5); ctx.stroke();
             drawDashedLine(T_x, objY, F_x, centerY, 'rgba(255, 50, 100, 0.3)'); 
        }

        ctx.strokeStyle = 'rgba(0, 242, 254, 0.5)'; ctx.beginPath(); ctx.moveTo(objX, objY); ctx.lineTo(T_x, centerY); 
        let d_o = T_x - objX; let h_o = centerY - objY;
        ctx.lineTo(T_x - 1000, centerY + h_o * (1000/d_o)); ctx.stroke();
        if (imgX > T_x) drawDashedLine(T_x, centerY, imgX, imgY, 'rgba(0, 242, 254, 0.3)'); 
    }

    function drawAxis(centerY, T_x) {
        if (!showAxis) return; 
        ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(width, centerY);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 1.5; ctx.stroke();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 2;
        for (let x = T_x; x > 0; x -= 50) { ctx.beginPath(); ctx.moveTo(x, centerY - 6); ctx.lineTo(x, centerY + 6); ctx.stroke(); }
        for (let x = T_x; x < width; x += 50) { ctx.beginPath(); ctx.moveTo(x, centerY - 6); ctx.lineTo(x, centerY + 6); ctx.stroke(); }
    }
    
    function drawPoints(centerY, T_x, F_x, M_x) {
        ctx.font = 'bold 12px Segoe UI'; ctx.textAlign = 'center';
        const drawPoint = (x, label) => {
            ctx.beginPath(); ctx.arc(x, centerY, 5, 0, Math.PI*2); 
            ctx.fillStyle = '#ffffff'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#000000'; ctx.stroke();
            ctx.fillStyle = C_ACCENT; ctx.shadowBlur = 4; ctx.shadowColor = '#000000';
            ctx.fillText(label, x, centerY + 24); ctx.shadowBlur = 0; 
        };
        if (showT) drawPoint(T_x, 'Tepe noktasƒ±'); 
        if (showF) drawPoint(F_x, 'Odak noktasƒ±'); 
        if (showM) drawPoint(M_x, 'Merkez noktasƒ±');
    }
    
    function drawMirror(centerY, R, M_x) {
        let ap = Math.asin(0.55); let start = mirrorType === 'cukur' ? -ap : Math.PI -ap; let end = mirrorType === 'cukur' ? ap : Math.PI+ap;
        ctx.beginPath(); ctx.arc(M_x, centerY, R, start, end);
        ctx.strokeStyle = C_ACCENT; ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.shadowBlur = 15; ctx.shadowColor = C_ACCENT; ctx.stroke(); ctx.shadowBlur = 0;
        ctx.save(); ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 2;
        for (let a = start; a <= end; a += 0.05) {
            let px = M_x + R*Math.cos(a), py = centerY + R*Math.sin(a);
            let dir = mirrorType === 'cukur' ? a : a + Math.PI;
            ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + 15*Math.cos(dir+0.4), py + 15*Math.sin(dir+0.4)); ctx.stroke();
        }
        ctx.restore();
    }
    
    function drawPortableRuler() {
        if (!showRuler) return;
        ctx.save(); ctx.translate(ruler.x, ruler.y);
        ctx.fillStyle = 'rgba(0, 242, 254, 0.1)'; ctx.strokeStyle = 'rgba(0, 242, 254, 0.6)'; ctx.lineWidth = 1;
        ctx.beginPath(); if (ctx.roundRect) ctx.roundRect(0, 0, ruler.w, ruler.h, 6); else ctx.rect(0, 0, ruler.w, ruler.h);
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = C_ACCENT; ctx.font = '10px Segoe UI'; ctx.textAlign = 'center';
        for (let i = 0; i <= ruler.w; i += 10) {
            let isMajor = (i % 50 === 0); let tickH = isMajor ? 12 : 6;
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, tickH); ctx.stroke();
            if (isMajor) ctx.fillText(i, i, tickH + 12);
        }
        ctx.restore();
    }
    
    function drawModernLaser() {
        ctx.save(); ctx.translate(laser.x, laser.y); ctx.rotate(laser.angle);
        let grad = ctx.createLinearGradient(-40, -15, 40, 15); 
        grad.addColorStop(0, '#222'); grad.addColorStop(0.5, '#444'); grad.addColorStop(1, '#222');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(-40, -10); ctx.lineTo(25, -10); ctx.lineTo(40, -5); ctx.lineTo(40, 5); ctx.lineTo(25, 10); ctx.lineTo(-40, 10); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = C_ACCENT; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-20, -10); ctx.lineTo(-20, 10); ctx.moveTo(10, -10); ctx.lineTo(10, 10); ctx.stroke();
        ctx.shadowBlur = 20; ctx.shadowColor = C_LASER; ctx.fillStyle = laser.isDraggingTip ? '#fff' : C_LASER; ctx.beginPath(); ctx.arc(45, 0, 6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = C_LASER; ctx.beginPath(); ctx.arc(48, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
    
    function calculateAndDrawRay(M_x, centerY, F_x, R) {
        let dx = Math.cos(laser.angle), dy = Math.sin(laser.angle);
        let startX = laser.x + 48 * dx, startY = laser.y + 48 * dy;
        let cx = M_x, cy = centerY, r = R; let fx = startX - cx, fy = startY - cy;
        let a = dx*dx + dy*dy, b = 2*(fx*dx + fy*dy), c = (fx*fx + fy*fy) - r*r; let disc = b*b - 4*a*c; let intersection = null;
        if (disc >= 0) {
            let t1 = (-b - Math.sqrt(disc)) / (2*a), t2 = (-b + Math.sqrt(disc)) / (2*a); let validPoints = [];
            for (let t of [t1, t2]) {
                if (t > 0.1) {
                    let ix = startX + t*dx, iy = startY + t*dy;
                    if (Math.abs(iy - centerY) < R * 0.55) {
                        if ((mirrorType === 'cukur' && ix >= cx) || (mirrorType === 'tumsek' && ix <= cx)) validPoints.push({x: ix, y: iy, t: t});
                    }
                }
            }
            if (validPoints.length > 0) { validPoints.sort((a, b) => a.t - b.t); intersection = validPoints[0]; }
        }

        ctx.strokeStyle = C_LASER; ctx.lineWidth = 3; ctx.shadowBlur = 20; ctx.shadowColor = C_LASER; ctx.beginPath(); ctx.moveTo(startX, startY);
        if (intersection) {
            ctx.lineTo(intersection.x, intersection.y); ctx.stroke(); ctx.shadowBlur = 0;
            if (showNormal) drawNormal(M_x, centerY, intersection.x, intersection.y);

            let rx, ry;
            if (Math.abs(dy) < 0.01) { 
                let tdx = intersection.x - F_x, tdy = intersection.y - centerY, mag = Math.hypot(tdx, tdy);
                rx = mirrorType === 'cukur' ? -tdx/mag : tdx/mag; ry = mirrorType === 'cukur' ? -tdy/mag : tdy/mag;
                if (mirrorType === 'tumsek') drawDashedLine(intersection.x, intersection.y, F_x, centerY, C_LASER);
            } else { 
                let nAngle = Math.atan2(intersection.y - centerY, intersection.x - M_x);
                let alpha = mirrorType === 'cukur' ? nAngle + Math.PI : nAngle;
                let refAngle = 2 * alpha - laser.angle - Math.PI;
                rx = Math.cos(refAngle); ry = Math.sin(refAngle);
            }
            ctx.strokeStyle = C_LASER; ctx.lineWidth = 3; ctx.shadowBlur = 20; ctx.shadowColor = C_LASER; ctx.beginPath(); ctx.moveTo(intersection.x, intersection.y); ctx.lineTo(intersection.x + rx*3000, intersection.y + ry*3000); ctx.stroke(); ctx.shadowBlur = 0;
        } else {
            ctx.lineTo(startX + dx*3000, startY + dy*3000); ctx.stroke(); ctx.shadowBlur = 0;
        }
    }

    function drawDashedLine(x1, y1, x2, y2, color) {
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.setLineDash([8, 8]); ctx.stroke(); ctx.setLineDash([]);
    }

    function updateInfoRayMode() {
        infoOverlay.innerHTML = `<div class="info-section">üõ†Ô∏è <span class="hl">I≈üƒ±n Modu</span></div><div class="info-divider"></div><div class="info-section">Lazerin g√∂vdesini s√ºr√ºkleyin, ucundan a√ßƒ±sƒ±nƒ± ayarlayƒ±n.</div>`;
    }
    
    function updateInfoImageMode(d_o, d_i, m) {
        if (d_i === null || isNaN(d_i)) { 
            infoOverlay.innerHTML = `<div class="info-section">üõ†Ô∏è <span class="hl">G√∂r√ºnt√º Modu</span></div><div class="info-divider"></div><div class="info-section"><span class="hl-obj">Cisim Odak noktasƒ±nda:</span> G√∂r√ºnt√º sonsuzda.</div>`; return; 
        }
        let type = d_i > 0 ? "Ger√ßek" : "Sanal";
        let orient = m < 0 ? "Ters" : "D√ºz";
        let size = Math.abs(m) > 1.05 ? "B√ºy√ºk" : (Math.abs(m) < 0.95 ? "K√º√ß√ºk" : "E≈üit");
        infoOverlay.innerHTML = `
            <div class="info-section">üõ†Ô∏è <span class="hl">G√∂r√ºnt√º Modu</span></div><div class="info-divider"></div>
            <div class="info-section">üìè <span class="hl-obj">Cisim:</span> ${Math.round(d_o)}br</div><div class="info-divider"></div>
            <div class="info-section">üìè <span class="hl-img">G√∂r√ºnt√º:</span> ${Math.round(Math.abs(d_i))}br</div><div class="info-divider"></div>
            <div class="info-section">üîé ${Math.abs(m).toFixed(2)}x B√ºy√ºtme</div><div class="info-divider"></div>
            <div class="info-section">üìå ${type}, ${orient}, ${size}</div>
        `;
    }

    setTimeout(resize, 100);
</script>
</body>
</html>