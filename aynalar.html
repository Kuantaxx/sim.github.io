<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Tırtıklı Ayna - Düzlem Ayna Simülasyonu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .simulation-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #ffffff, #f7fafc);
            cursor: grab;
            display: block;
            touch-action: none;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .controls-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 280px;
            z-index: 1000;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            transform: scale(1);
            transition: all 0.3s ease;
        }
        
        .control-section {
            margin-bottom: 12px;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .control-section h3 {
            font-size: 12px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.1);
            outline: none;
            appearance: none;
            margin-bottom: 4px;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.6);
        }
        
        select, button {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #2d3748;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 36px;
        }
        
        select:hover, select:focus {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 4px;
        }
        
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        button.active {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }
        
        .value-display {
            font-size: 9px;
            font-weight: 700;
            color: #2d3748;
            text-align: center;
            background: rgba(0, 0, 0, 0.05);
            padding: 3px 6px;
            border-radius: 4px;
            margin-top: 2px;
        }
        
        .info-overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 320px;
            z-index: 1000;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            transform: scale(1);
            transition: all 0.3s ease;
        }
        
        .info-section {
            margin-bottom: 12px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section h4 {
            font-size: 12px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .legend-item {
            font-size: 9px;
            color: #4a5568;
            margin: 3px 0;
            display: flex;
            align-items: center;
            gap: 6px;
            line-height: 1.3;
        }
        
        .legend-symbol {
            min-width: 16px;
            text-align: center;
            font-weight: bold;
            font-size: 10px;
        }
        
        .status-item {
            font-size: 10px;
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .status-label {
            color: #4a5568;
            font-weight: 600;
            margin-right: 4px;
        }
        
        .status-value {
            color: #2d3748;
            font-weight: 700;
        }
        
        .status-warning {
            color: #e53e3e;
            font-weight: 700;
        }
        
        .measurement-control-group {
            margin-bottom: 6px;
        }
        
        .measurement-control-group:last-child {
            margin-bottom: 0;
        }
        
        .measurement-control-group label {
            display: block;
            font-size: 9px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        /* Tablet Responsive (768px - 1024px) */
        @media (max-width: 1024px) and (min-width: 769px) {
            .controls-overlay,
            .info-overlay {
                max-width: 240px;
                padding: 10px;
            }
            
            .control-section h3,
            .info-section h4 {
                font-size: 11px;
            }
            
            select, button {
                font-size: 10px;
                padding: 6px 8px;
                min-height: 32px;
            }
        }
        
        /* Tablet ve küçük laptop (481px - 768px) */
        @media (max-width: 768px) and (min-width: 481px) {
            .controls-overlay {
                max-width: 200px;
                padding: 8px;
                top: 5px;
                left: 5px;
                max-height: calc(100vh - 100px);
            }
            
            .info-overlay {
                max-width: 220px;
                padding: 8px;
                top: 5px;
                right: 5px;
                max-height: calc(100vh - 100px);
            }
            
            .control-section h3,
            .info-section h4 {
                font-size: 10px;
            }
            
            .legend-item,
            .status-item {
                font-size: 8px;
            }
            
            select, button {
                font-size: 9px;
                padding: 6px 8px;
                min-height: 30px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
        }
        
        /* Mobil telefonlar (320px - 480px) */
        @media (max-width: 480px) {
            .controls-overlay {
                max-width: 160px;
                padding: 6px;
                top: 5px;
                left: 5px;
                max-height: calc(100vh - 80px);
                border-radius: 8px;
            }
            
            .info-overlay {
                max-width: 180px;
                padding: 6px;
                top: 5px;
                right: 5px;
                max-height: calc(100vh - 80px);
                border-radius: 8px;
            }
            
            .control-section,
            .info-section {
                margin-bottom: 8px;
            }
            
            .control-section h3,
            .info-section h4 {
                font-size: 9px;
                margin-bottom: 6px;
            }
            
            .control-group,
            .measurement-control-group {
                margin-bottom: 6px;
            }
            
            .control-group label,
            .measurement-control-group label {
                font-size: 8px;
                margin-bottom: 2px;
            }
            
            .legend-item {
                font-size: 7px;
                margin: 2px 0;
                gap: 4px;
            }
            
            .legend-symbol {
                min-width: 12px;
                font-size: 8px;
            }
            
            .status-item {
                font-size: 8px;
                margin: 1px 0;
                flex-direction: column;
                align-items: flex-start;
            }
            
            .status-label {
                margin-right: 0;
                margin-bottom: 1px;
            }
            
            select, button {
                font-size: 8px;
                padding: 6px 6px;
                min-height: 28px;
                border-radius: 4px;
            }
            
            .value-display {
                font-size: 8px;
                padding: 2px 4px;
            }
            
            input[type="range"] {
                height: 6px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }
        }
        
        /* Çok küçük ekranlar (240px - 320px) */
        @media (max-width: 320px) {
            .controls-overlay {
                max-width: 140px;
                padding: 4px;
                font-size: 7px;
            }
            
            .info-overlay {
                max-width: 160px;
                padding: 4px;
                font-size: 7px;
            }
            
            .control-section h3,
            .info-section h4 {
                font-size: 8px;
                margin-bottom: 4px;
            }
            
            .legend-item,
            .status-item {
                font-size: 6px;
                margin: 1px 0;
            }
            
            select, button {
                font-size: 7px;
                padding: 4px 4px;
                min-height: 24px;
            }
            
            .value-display {
                font-size: 7px;
                padding: 1px 3px;
            }
        }
        
        /* Landscape orientasyon için özel ayarlar */
        @media (max-height: 500px) and (orientation: landscape) {
            .controls-overlay,
            .info-overlay {
                max-height: calc(100vh - 60px);
                padding: 6px;
            }
            
            .control-section,
            .info-section {
                margin-bottom: 6px;
            }
            
            .control-section h3,
            .info-section h4 {
                font-size: 9px;
                margin-bottom: 4px;
            }
            
            select, button {
                min-height: 26px;
                font-size: 9px;
            }
        }
        
        /* Touch-friendly improvements */
        @media (pointer: coarse) {
            button {
                min-height: 36px;
                font-size: 10px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 22px;
                height: 22px;
            }
            
            select {
                min-height: 36px;
            }
        }
        
        /* High DPI ekranlar için */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .controls-overlay,
            .info-overlay {
                backdrop-filter: blur(15px);
            }
        }
        
        /* Dark mode desteği */
        @media (prefers-color-scheme: dark) {
            .controls-overlay,
            .info-overlay {
                background: rgba(45, 55, 72, 0.95);
                color: #f7fafc;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .control-section h3,
            .info-section h4 {
                color: #f7fafc;
            }
            
            .status-label,
            .legend-item {
                color: #cbd5e0;
            }
            
            .status-value {
                color: #f7fafc;
            }
            
            select, button {
                background: rgba(255, 255, 255, 0.1);
                color: #f7fafc;
            }
        }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <canvas id="mirrorCanvas"></canvas>
        
        <div class="controls-overlay">
            <div class="control-section">
                <h3>🎯 Cisim</h3>
                <div class="control-group">
                    <label for="objectType">Tür</label>
                    <select id="objectType">
                        <option value="circle">🔴 Daire</option>
                        <option value="arrow" selected>🏹 Ok</option>
                        <option value="square">🟥 Kare</option>
                        <option value="triangle">🔺 Üçgen</option>
                        <option value="letter_e">📝 E Harfi</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="objectSize">Boyut</label>
                    <input type="range" id="objectSize" min="2" max="8" value="4" step="0.5">
                    <div class="value-display" id="sizeValue">4.0 cm</div>
                </div>
                <div class="control-group">
                    <label for="objectRotation">Açı</label>
                    <input type="range" id="objectRotation" min="0" max="360" value="0" step="15">
                    <div class="value-display" id="rotationValue">0°</div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>🪞 Ayna</h3>
                <div class="control-group">
                    <label for="mirrorAngle">Açı</label>
                    <input type="range" id="mirrorAngle" min="0" max="180" value="90" step="1">
                    <div class="value-display" id="angleValue">90°</div>
                </div>
            </div>
        </div>
        
        <div class="info-overlay">
            <div class="info-section">
                <h4>📐 Araçlar</h4>
                <div class="measurement-control-group">
                    <label for="rulerLength">Cetvel</label>
                    <input type="range" id="rulerLength" min="10" max="40" value="25" step="2">
                    <div class="value-display" id="rulerLengthValue">25.0 cm</div>
                </div>
                <button id="showRuler" onclick="toggleRuler()">Cetvel: KAPALI</button>
                <button id="showProtractor" onclick="toggleProtractor()">Açı Ölçer: KAPALI</button>
                <button id="showExtensions" onclick="toggleExtensions()">Uzantılar: AÇIK</button>
            </div>
            
            <div class="info-section">
                <h4>📋 Göstergeler</h4>
                <div class="legend-item">
                    <span class="legend-symbol">🔴</span>
                    <span>Gerçek Cisim</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">🔵</span>
                    <span>Sanal Görüntü</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">🟠</span>
                    <span>Gelen Işın</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">🟢</span>
                    <span>Yansıyan Işın</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">🪞</span>
                    <span>Düzlem Ayna</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">📏</span>
                    <span>Cetvel</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">📐</span>
                    <span>Açı Ölçer</span>
                </div>
            </div>
            
            <div class="info-section">
                <h4>📊 Durum</h4>
                <div class="status-item">
                    <span class="status-label">Sistem:</span>
                    <span class="status-value" id="systemStatus">Normal</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Görüntü:</span>
                    <span class="status-value" id="imageStatus">Oluşuyor</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Cisim:</span>
                    <span class="status-value" id="realDistance">--cm</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Görüntü:</span>
                    <span class="status-value" id="virtualDistance">--cm</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Cisim Açı:</span>
                    <span class="status-value" id="objectAngle">0°</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Ayna Açı:</span>
                    <span class="status-value" id="mirrorAngleStatus">90°</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ResponsiveMirrorSimulation {
            constructor() {
                this.canvas = document.getElementById('mirrorCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Canvas boyutunu tam ekrana ayarla
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 100);
                });
                
                // Responsive ölçek hesaplama
                this.calculateScale();
                
                // Canvas merkezini hesapla
                this.centerX = this.pxToCm(this.canvas.width / 2);
                this.centerY = this.pxToCm(this.canvas.height / 2);
                
                // Responsive element konumları
                this.initializeElements();
                
                // Sabit 2 ışın + uzantılar açık
                this.rayCount = 2;
                this.showExtensions = true;
                this.isDragging = false;
                this.dragTarget = null;
                this.lastMouse = { x: 0, y: 0 };
                
                this.setupEventListeners();
                this.setupControls();
                this.animate();
            }
            
            calculateScale() {
                // Ekran boyutuna göre dinamik ölçek
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const minDimension = Math.min(screenWidth, screenHeight);
                
                if (minDimension <= 320) {
                    this.scale = 4; // Çok küçük ekranlar
                } else if (minDimension <= 480) {
                    this.scale = 5; // Mobil telefonlar
                } else if (minDimension <= 768) {
                    this.scale = 6; // Büyük telefonlar / küçük tabletler
                } else if (minDimension <= 1024) {
                    this.scale = 7; // Tabletler
                } else {
                    this.scale = 8; // Masaüstü
                }
            }
            
            initializeElements() {
                // Ekran boyutuna göre element boyutları
                const scaleFactor = this.scale / 8; // 8 referans ölçek
                
                this.mirror = { 
                    x: this.centerX - 5 * scaleFactor,
                    y: this.centerY,
                    length: 35 * scaleFactor,
                    angle: Math.PI / 2
                };
                
                this.object = { 
                    x: this.centerX + 30 * scaleFactor,
                    y: this.centerY,
                    size: 4 * scaleFactor,
                    type: 'arrow',
                    rotation: 0
                };
                
                this.ruler = {
                    x: this.centerX,
                    y: this.centerY + 25 * scaleFactor,
                    length: 25 * scaleFactor,
                    angle: 0,
                    visible: false
                };
                
                this.protractor = {
                    x: this.centerX - 10 * scaleFactor,
                    y: this.centerY - 15 * scaleFactor,
                    radius: 20 * scaleFactor,
                    angle: 0,
                    visible: false
                };
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                if (this.canvas.width > 0 && this.canvas.height > 0) {
                    this.calculateScale();
                    this.centerX = this.pxToCm(this.canvas.width / 2);
                    this.centerY = this.pxToCm(this.canvas.height / 2);
                    
                    // Elementleri yeniden konumlandır
                    if (this.mirror) {
                        this.initializeElements();
                    }
                }
            }
            
            cmToPx(cm) { return cm * this.scale; }
            pxToCm(px) { return px / this.scale; }
            
            isObjectInFrontOfMirror() {
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const objectToMirror = {
                    x: this.mirror.x - this.object.x,
                    y: this.mirror.y - this.object.y
                };
                
                const dotProduct = objectToMirror.x * mirrorNormal.x + objectToMirror.y * mirrorNormal.y;
                return dotProduct > 0;
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleEnd());
                this.canvas.addEventListener('mouseleave', () => this.handleEnd());
                
                // Touch events (mobil)
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleStart(e.touches[0]);
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleMove(e.touches[0]);
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleEnd();
                }, { passive: false });
                
                // Zoom engelleme (mobil)
                document.addEventListener('gesturestart', e => e.preventDefault());
                document.addEventListener('gesturechange', e => e.preventDefault());
                document.addEventListener('gestureend', e => e.preventDefault());
            }
            
            setupControls() {
                const controls = {
                    mirrorAngle: document.getElementById('mirrorAngle'),
                    angleValue: document.getElementById('angleValue'),
                    objectSize: document.getElementById('objectSize'),
                    sizeValue: document.getElementById('sizeValue'),
                    objectType: document.getElementById('objectType'),
                    objectRotation: document.getElementById('objectRotation'),
                    rotationValue: document.getElementById('rotationValue'),
                    rulerLength: document.getElementById('rulerLength'),
                    rulerLengthValue: document.getElementById('rulerLengthValue')
                };
                
                controls.mirrorAngle.addEventListener('input', (e) => {
                    this.mirror.angle = (e.target.value * Math.PI) / 180;
                    controls.angleValue.textContent = e.target.value + '°';
                });
                
                controls.objectSize.addEventListener('input', (e) => {
                    const scaleFactor = this.scale / 8;
                    this.object.size = parseFloat(e.target.value) * scaleFactor;
                    controls.sizeValue.textContent = e.target.value + ' cm';
                });
                
                controls.objectType.addEventListener('change', (e) => {
                    this.object.type = e.target.value;
                });
                
                controls.objectRotation.addEventListener('input', (e) => {
                    this.object.rotation = (parseFloat(e.target.value) * Math.PI) / 180;
                    controls.rotationValue.textContent = e.target.value + '°';
                });
                
                controls.rulerLength.addEventListener('input', (e) => {
                    const scaleFactor = this.scale / 8;
                    this.ruler.length = parseFloat(e.target.value) * scaleFactor;
                    controls.rulerLengthValue.textContent = e.target.value + ' cm';
                });
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: this.pxToCm((e.clientX - rect.left) * scaleX),
                    y: this.pxToCm((e.clientY - rect.top) * scaleY)
                };
            }
            
            handleStart(e) {
                const mouse = this.getMousePos(e);
                this.lastMouse = mouse;
                
                // Touch sensitivity adjustment for mobile
                const touchSensitivity = window.innerWidth <= 768 ? 2 : 1;
                
                // Cisim kontrolü
                const objDist = Math.sqrt(
                    Math.pow(mouse.x - this.object.x, 2) + 
                    Math.pow(mouse.y - this.object.y, 2)
                );
                
                if (objDist < this.object.size + touchSensitivity) {
                    this.isDragging = true;
                    this.dragTarget = 'object';
                    return;
                }
                
                // Cetvel kontrolü
                if (this.ruler.visible) {
                    const rulerDist = this.distanceToRuler(mouse);
                    if (rulerDist < 2 * touchSensitivity) {
                        this.isDragging = true;
                        this.dragTarget = 'ruler';
                        this.rulerDragMode = this.isNearRulerEnd(mouse) ? 'rotate' : 'move';
                        return;
                    }
                }
                
                // Açı ölçer kontrolü
                if (this.protractor.visible) {
                    const protractorDist = Math.sqrt(
                        Math.pow(mouse.x - this.protractor.x, 2) + 
                        Math.pow(mouse.y - this.protractor.y, 2)
                    );
                    
                    if (protractorDist < this.protractor.radius + touchSensitivity) {
                        this.isDragging = true;
                        this.dragTarget = 'protractor';
                        
                        if (protractorDist < 5 * touchSensitivity) {
                            this.protractorDragMode = 'move';
                        } else {
                            this.protractorDragMode = 'rotate';
                        }
                        return;
                    }
                }
                
                // Ayna kontrolü
                const mirrorStart = {
                    x: this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2,
                    y: this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2
                };
                const mirrorEnd = {
                    x: this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2,
                    y: this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2
                };
                
                const distToMirror = this.distanceToLine(mouse, mirrorStart, mirrorEnd);
                if (distToMirror < 2.5 * touchSensitivity) {
                    this.isDragging = true;
                    this.dragTarget = 'mirror';
                    
                    const distToCenter = Math.sqrt(
                        Math.pow(mouse.x - this.mirror.x, 2) + 
                        Math.pow(mouse.y - this.mirror.y, 2)
                    );
                    
                    this.mirrorDragMode = distToCenter < 5 * touchSensitivity ? 'move' : 'rotate';
                }
            }
            
            isNearRulerEnd(point) {
                const endX = this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2;
                const endY = this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2;
                const distToEnd = Math.sqrt(
                    Math.pow(point.x - endX, 2) + Math.pow(point.y - endY, 2)
                );
                const touchSensitivity = window.innerWidth <= 768 ? 4 : 3;
                return distToEnd < touchSensitivity;
            }
            
            handleMove(e) {
                if (!this.isDragging) return;
                
                const mouse = this.getMousePos(e);
                
                if (this.dragTarget === 'object') {
                    this.object.x = Math.max(this.object.size, 
                        Math.min(this.pxToCm(this.canvas.width) - this.object.size, mouse.x));
                    this.object.y = Math.max(this.object.size, 
                        Math.min(this.pxToCm(this.canvas.height) - this.object.size, mouse.y));
                        
                } else if (this.dragTarget === 'mirror') {
                    if (this.mirrorDragMode === 'move') {
                        this.mirror.x = Math.max(10, 
                            Math.min(this.pxToCm(this.canvas.width) - 10, mouse.x));
                        this.mirror.y = Math.max(10, 
                            Math.min(this.pxToCm(this.canvas.height) - 10, mouse.y));
                    } else {
                        const centerToMouse = Math.atan2(mouse.y - this.mirror.y, mouse.x - this.mirror.x);
                        this.mirror.angle = centerToMouse;
                        
                        const degrees = Math.round((this.mirror.angle * 180) / Math.PI);
                        const normalizedDegrees = ((degrees % 360) + 360) % 360;
                        document.getElementById('mirrorAngle').value = normalizedDegrees;
                        document.getElementById('angleValue').textContent = normalizedDegrees + '°';
                    }
                    
                } else if (this.dragTarget === 'ruler') {
                    if (this.rulerDragMode === 'move') {
                        this.ruler.x = mouse.x;
                        this.ruler.y = mouse.y;
                    } else if (this.rulerDragMode === 'rotate') {
                        const centerToMouse = Math.atan2(mouse.y - this.ruler.y, mouse.x - this.ruler.x);
                        this.ruler.angle = centerToMouse;
                    }
                    
                } else if (this.dragTarget === 'protractor') {
                    if (this.protractorDragMode === 'move') {
                        this.protractor.x = Math.max(this.protractor.radius, 
                            Math.min(this.pxToCm(this.canvas.width) - this.protractor.radius, mouse.x));
                        this.protractor.y = Math.max(this.protractor.radius, 
                            Math.min(this.pxToCm(this.canvas.height) - this.protractor.radius, mouse.y));
                    } else if (this.protractorDragMode === 'rotate') {
                        const centerToMouse = Math.atan2(mouse.y - this.protractor.y, mouse.x - this.protractor.x);
                        this.protractor.angle = centerToMouse;
                    }
                }
                
                this.lastMouse = mouse;
            }
            
            handleEnd() {
                this.isDragging = false;
                this.dragTarget = null;
                this.rulerDragMode = null;
                this.mirrorDragMode = null;
                this.protractorDragMode = null;
            }
            
            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            distanceToRuler(point) {
                const rulerStart = {
                    x: this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2,
                    y: this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2
                };
                const rulerEnd = {
                    x: this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2,
                    y: this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2
                };
                
                return this.distanceToLine(point, rulerStart, rulerEnd);
            }
            
            calculateReflection(incident, normal) {
                const dot = incident.x * normal.x + incident.y * normal.y;
                return {
                    x: incident.x - 2 * dot * normal.x,
                    y: incident.y - 2 * dot * normal.y
                };
            }
            
            getVirtualImage() {
                if (!this.isObjectInFrontOfMirror()) {
                    return null;
                }
                
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const toMirror = {
                    x: this.mirror.x - this.object.x,
                    y: this.mirror.y - this.object.y
                };
                
                const normalDist = toMirror.x * mirrorNormal.x + toMirror.y * mirrorNormal.y;
                
                return {
                    x: this.object.x + 2 * normalDist * mirrorNormal.x,
                    y: this.object.y + 2 * normalDist * mirrorNormal.y
                };
            }
            
            lineIntersection(p1, p2, p3, p4) {
                const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                if (Math.abs(denom) < 0.001) return null;
                
                const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
                const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;
                
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return null;
            }
            
            // Ok çizme fonksiyonu (responsive)
            drawArrow(fromX, fromY, toX, toY, color, lineWidth = 3) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length < 10) return;
                
                const unitX = dx / length;
                const unitY = dy / length;
                
                const arrowPos = 0.85;
                const arrowX = fromX + dx * arrowPos;
                const arrowY = fromY + dy * arrowPos;
                
                // Responsive ok boyutu
                const scaleFactor = this.scale / 8;
                const arrowSize = Math.min(15 * scaleFactor, length * 0.15);
                const arrowAngle = Math.PI / 6;
                
                const leftWingX = arrowX - (unitX * Math.cos(arrowAngle) - unitY * Math.sin(arrowAngle)) * arrowSize;
                const leftWingY = arrowY - (unitX * Math.sin(arrowAngle) + unitY * Math.cos(arrowAngle)) * arrowSize;
                
                const rightWingX = arrowX - (unitX * Math.cos(-arrowAngle) - unitY * Math.sin(-arrowAngle)) * arrowSize;
                const rightWingY = arrowY - (unitX * Math.sin(-arrowAngle) + unitY * Math.cos(-arrowAngle)) * arrowSize;
                
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = lineWidth * scaleFactor;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(fromX, fromY);
                this.ctx.lineTo(toX, toY);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(leftWingX, leftWingY);
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(rightWingX, rightWingY);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(leftWingX, leftWingY);
                this.ctx.lineTo(rightWingX, rightWingY);
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGrid();
                this.drawMirror();
                this.drawObject();
                
                if (this.isObjectInFrontOfMirror()) {
                    this.drawVirtualImage();
                    this.drawRays();
                }
                
                if (this.ruler.visible) {
                    this.drawRuler();
                }
                
                if (this.protractor.visible) {
                    this.drawProtractor();
                }
                
                this.updateStatus();
            }
            
            drawGrid() {
                const scaleFactor = this.scale / 8;
                this.ctx.strokeStyle = 'rgba(100, 116, 139, 0.1)';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x < this.canvas.width; x += this.cmToPx(5 * scaleFactor)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += this.cmToPx(5 * scaleFactor)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                this.ctx.strokeStyle = 'rgba(100, 116, 139, 0.05)';
                for (let x = 0; x < this.canvas.width; x += this.cmToPx(1 * scaleFactor)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += this.cmToPx(1 * scaleFactor)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            // Tırtıklı ayna çizme fonksiyonu (responsive)
            drawMirror() {
                const startX = this.cmToPx(this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2);
                const startY = this.cmToPx(this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2);
                const endX = this.cmToPx(this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2);
                const endY = this.cmToPx(this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2);
                
                const scaleFactor = this.scale / 8;
                
                // Ayna yüzeyi
                const gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, '#E2E8F0');
                gradient.addColorStop(0.3, '#CBD5E0');
                gradient.addColorStop(0.7, '#A0AEC0');
                gradient.addColorStop(1, '#718096');
                
                this.ctx.strokeStyle = gradient;
                this.ctx.lineWidth = 16 * scaleFactor;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Ayna kenarı
                this.ctx.strokeStyle = '#2D3748';
                this.ctx.lineWidth = 3 * scaleFactor;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Sol tarafa tırtık ekleme
                this.drawMirrorNotches(startX, startY, endX, endY);
                
                // Merkez tutacağı
                this.ctx.fillStyle = '#667EEA';
                this.ctx.beginPath();
                this.ctx.arc(this.cmToPx(this.mirror.x), this.cmToPx(this.mirror.y), 8 * scaleFactor, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#4C51BF';
                this.ctx.lineWidth = 2 * scaleFactor;
                this.ctx.stroke();
                
                // Normal çizgisi
                this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                this.ctx.lineWidth = 2 * scaleFactor;
                this.ctx.setLineDash([5 * scaleFactor, 5 * scaleFactor]);
                const normalStartX = this.cmToPx(this.mirror.x);
                const normalStartY = this.cmToPx(this.mirror.y);
                const normalEndX = this.cmToPx(this.mirror.x - Math.sin(this.mirror.angle) * 8 * scaleFactor);
                const normalEndY = this.cmToPx(this.mirror.y + Math.cos(this.mirror.angle) * 8 * scaleFactor);
                
                this.ctx.beginPath();
                this.ctx.moveTo(normalStartX, normalStartY);
                this.ctx.lineTo(normalEndX, normalEndY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            // Ayna tırtık çizme fonksiyonu (responsive)
            drawMirrorNotches(startX, startY, endX, endY) {
                const mirrorLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const unitX = (endX - startX) / mirrorLength;
                const unitY = (endY - startY) / mirrorLength;
                
                const leftNormalX = -unitY;
                const leftNormalY = unitX;
                
                const scaleFactor = this.scale / 8;
                const notchSpacing = this.cmToPx(2 * scaleFactor);
                const notchLength = 8 * scaleFactor;
                const notchCount = Math.floor(mirrorLength / notchSpacing);
                
                this.ctx.strokeStyle = '#2D3748';
                this.ctx.lineWidth = 2 * scaleFactor;
                
                for (let i = 1; i < notchCount; i++) {
                    const t = i / notchCount;
                    const notchX = startX + t * (endX - startX);
                    const notchY = startY + t * (endY - startY);
                    
                    const notchEndX = notchX + leftNormalX * notchLength;
                    const notchEndY = notchY + leftNormalY * notchLength;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(notchX, notchY);
                    this.ctx.lineTo(notchEndX, notchEndY);
                    this.ctx.stroke();
                }
            }
            
            drawObject() {
                const x = this.cmToPx(this.object.x);
                const y = this.cmToPx(this.object.y);
                const size = this.cmToPx(this.object.size);
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, '#FC8181');
                gradient.addColorStop(1, '#E53E3E');
                
                this.ctx.fillStyle = gradient;
                this.ctx.strokeStyle = '#C53030';
                this.ctx.lineWidth = 3 * (this.scale / 8);
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(this.object.rotation);
                
                switch(this.object.type) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, 0);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.lineTo(size * 0.2, -size * 0.6);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(size * 0.2, size * 0.6);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-size, -size, size * 2, size * 2);
                        this.ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                        
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(-size, size);
                        this.ctx.lineTo(size, size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'letter_e':
                        const lineWidth = size * 0.15;
                        this.ctx.lineWidth = lineWidth;
                        
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, lineWidth, size * 1.6);
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, size * 1.4, lineWidth);
                        this.ctx.fillRect(-size * 0.8, -lineWidth/2, size * 1.2, lineWidth);
                        this.ctx.fillRect(-size * 0.8, size * 0.8 - lineWidth, size * 1.4, lineWidth);
                        break;
                }
                
                this.ctx.restore();
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4 * (this.scale / 8), 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawVirtualImage() {
                const virtualPos = this.getVirtualImage();
                if (!virtualPos) return;
                
                const x = this.cmToPx(virtualPos.x);
                const y = this.cmToPx(virtualPos.y);
                const size = this.cmToPx(this.object.size);
                
                const scaleFactor = this.scale / 8;
                this.ctx.setLineDash([10 * scaleFactor, 10 * scaleFactor]);
                this.ctx.strokeStyle = '#667EEA';
                this.ctx.lineWidth = 3 * scaleFactor;
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.4)');
                gradient.addColorStop(1, 'rgba(102, 126, 234, 0.2)');
                this.ctx.fillStyle = gradient;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(-this.object.rotation);
                
                switch(this.object.type) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.ctx.scale(-1, 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, 0);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.lineTo(size * 0.2, -size * 0.6);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(size * 0.2, size * 0.6);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-size, -size, size * 2, size * 2);
                        this.ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                        
                    case 'triangle':
                        this.ctx.scale(-1, 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(-size, size);
                        this.ctx.lineTo(size, size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'letter_e':
                        this.ctx.scale(-1, 1);
                        const lineWidth = size * 0.15;
                        
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, lineWidth, size * 1.6);
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, size * 1.4, lineWidth);
                        this.ctx.fillRect(-size * 0.8, -lineWidth/2, size * 1.2, lineWidth);
                        this.ctx.fillRect(-size * 0.8, size * 0.8 - lineWidth, size * 1.4, lineWidth);
                        break;
                }
                
                this.ctx.restore();
                this.ctx.setLineDash([]);
                
                this.ctx.fillStyle = '#667EEA';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4 * scaleFactor, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawRays() {
                if (!this.isObjectInFrontOfMirror()) return;
                
                const mirrorStartX = this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2;
                const mirrorStartY = this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2;
                const mirrorEndX = this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2;
                const mirrorEndY = this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2;
                
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const virtualPos = this.getVirtualImage();
                const rayAngles = [Math.PI * 0.25, Math.PI * 1.75];
                const scaleFactor = this.scale / 8;
                
                for (let i = 0; i < this.rayCount; i++) {
                    const angle = rayAngles[i];
                    const rayStartX = this.object.x + Math.cos(angle) * this.object.size * 0.8;
                    const rayStartY = this.object.y + Math.sin(angle) * this.object.size * 0.8;
                    
                    const toMirrorX = this.mirror.x - rayStartX;
                    const toMirrorY = this.mirror.y - rayStartY;
                    const length = Math.sqrt(toMirrorX * toMirrorX + toMirrorY * toMirrorY);
                    const dirX = toMirrorX / length;
                    const dirY = toMirrorY / length;
                    
                    const rayEnd = {
                        x: rayStartX + dirX * 120 * scaleFactor,
                        y: rayStartY + dirY * 120 * scaleFactor
                    };
                    
                    const intersection = this.lineIntersection(
                        { x: rayStartX, y: rayStartY },
                        rayEnd,
                        { x: mirrorStartX, y: mirrorStartY },
                        { x: mirrorEndX, y: mirrorEndY }
                    );
                    
                    if (intersection) {
                        // Gelen ışın
                        this.drawArrow(
                            this.cmToPx(rayStartX), 
                            this.cmToPx(rayStartY),
                            this.cmToPx(intersection.x), 
                            this.cmToPx(intersection.y),
                            '#F39C12', 
                            4
                        );
                        
                        // Yansıyan ışın
                        const incident = { x: dirX, y: dirY };
                        const reflected = this.calculateReflection(incident, mirrorNormal);
                        
                        const reflectedEndX = intersection.x + reflected.x * 25 * scaleFactor;
                        const reflectedEndY = intersection.y + reflected.y * 25 * scaleFactor;
                        
                        this.drawArrow(
                            this.cmToPx(intersection.x), 
                            this.cmToPx(intersection.y),
                            this.cmToPx(reflectedEndX), 
                            this.cmToPx(reflectedEndY),
                            '#27AE60', 
                            4
                        );
                        
                        // Uzantılar görüntüye kadar
                        if (this.showExtensions && virtualPos) {
                            const extensionEndX = virtualPos.x + Math.cos(angle) * this.object.size * 0.8;
                            const extensionEndY = virtualPos.y + Math.sin(angle) * this.object.size * 0.8;
                            
                            this.ctx.strokeStyle = 'rgba(39, 174, 96, 0.6)';
                            this.ctx.lineWidth = 2 * scaleFactor;
                            this.ctx.setLineDash([10 * scaleFactor, 10 * scaleFactor]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.cmToPx(intersection.x), this.cmToPx(intersection.y));
                            this.ctx.lineTo(this.cmToPx(extensionEndX), this.cmToPx(extensionEndY));
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                        }
                        
                        // Kesişim noktası
                        this.ctx.fillStyle = '#F1C40F';
                        this.ctx.beginPath();
                        this.ctx.arc(this.cmToPx(intersection.x), this.cmToPx(intersection.y), 6 * scaleFactor, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        this.ctx.strokeStyle = '#D68910';
                        this.ctx.lineWidth = 2 * scaleFactor;
                        this.ctx.stroke();
                    }
                }
            }
            
            drawRuler() {
                const startX = this.cmToPx(this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2);
                const startY = this.cmToPx(this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2);
                const endX = this.cmToPx(this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2);
                const endY = this.cmToPx(this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2);
                
                const scaleFactor = this.scale / 8;
                
                this.ctx.strokeStyle = '#8D6E63';
                this.ctx.lineWidth = 8 * scaleFactor;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                this.ctx.strokeStyle = '#5D4037';
                this.ctx.lineWidth = 1 * scaleFactor;
                this.ctx.font = (10 * scaleFactor) + 'px Arial';
                this.ctx.fillStyle = '#3E2723';
                this.ctx.textAlign = 'center';
                
                const normalX = -Math.sin(this.ruler.angle);
                const normalY = Math.cos(this.ruler.angle);
                
                for (let i = 0; i <= this.ruler.length / scaleFactor; i += 1) {
                    const x = this.cmToPx(this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2 + Math.cos(this.ruler.angle) * i * scaleFactor);
                    const y = this.cmToPx(this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2 + Math.sin(this.ruler.angle) * i * scaleFactor);
                    
                    const markLength = (i % 5 === 0) ? 12 * scaleFactor : 8 * scaleFactor;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y);
                    this.ctx.lineTo(x + normalX * markLength, y + normalY * markLength);
                    this.ctx.stroke();
                    
                    if (i % 5 === 0) {
                        this.ctx.save();
                        this.ctx.translate(x + normalX * 16 * scaleFactor, y + normalY * 16 * scaleFactor);
                        this.ctx.rotate(this.ruler.angle);
                        this.ctx.fillText(i + 'cm', 0, 0);
                        this.ctx.restore();
                    }
                }
                
                this.ctx.fillStyle = '#FF5722';
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, 6 * scaleFactor, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawProtractor() {
                const centerX = this.cmToPx(this.protractor.x);
                const centerY = this.cmToPx(this.protractor.y);
                const radius = this.cmToPx(this.protractor.radius);
                
                const scaleFactor = this.scale / 8;
                
                // Açı ölçer gövdesi (yarım daire)
                this.ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                this.ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';
                this.ctx.lineWidth = 3 * scaleFactor;
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI, false);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                // Açı çizgileri
                this.ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';
                this.ctx.lineWidth = 1 * scaleFactor;
                this.ctx.font = (8 * scaleFactor) + 'px Arial';
                this.ctx.fillStyle = '#B8860B';
                this.ctx.textAlign = 'center';
                
                for (let angle = 0; angle <= 180; angle += 10) {
                    const radian = (angle * Math.PI) / 180 + this.protractor.angle;
                    const lineLength = (angle % 30 === 0) ? radius * 0.8 : radius * 0.9;
                    
                    const startX = centerX + Math.cos(radian) * lineLength;
                    const startY = centerY + Math.sin(radian) * lineLength;
                    const endX = centerX + Math.cos(radian) * radius;
                    const endY = centerY + Math.sin(radian) * radius;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                    this.ctx.stroke();
                    
                    // Açı değerleri (sadece büyük ekranlarda)
                    if (angle % 30 === 0 && scaleFactor > 0.6) {
                        const textX = centerX + Math.cos(radian) * (radius * 0.7);
                        const textY = centerY + Math.sin(radian) * (radius * 0.7);
                        
                        this.ctx.save();
                        this.ctx.translate(textX, textY);
                        this.ctx.rotate(radian - Math.PI/2);
                        this.ctx.fillText(angle + '°', 0, 0);
                        this.ctx.restore();
                    }
                }
                
                // Merkez noktası
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 6 * scaleFactor, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Döndürme tutacağı
                const handleX = centerX + Math.cos(this.protractor.angle + Math.PI) * radius * 0.8;
                const handleY = centerY + Math.sin(this.protractor.angle + Math.PI) * radius * 0.8;
                
                this.ctx.fillStyle = '#FF4500';
                this.ctx.beginPath();
                this.ctx.arc(handleX, handleY, 8 * scaleFactor, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            updateStatus() {
                if (this.isObjectInFrontOfMirror()) {
                    document.getElementById('systemStatus').textContent = 'Normal';
                    document.getElementById('systemStatus').className = 'status-value';
                    document.getElementById('imageStatus').textContent = 'Oluşuyor';
                    document.getElementById('imageStatus').className = 'status-value';
                    
                    const virtualPos = this.getVirtualImage();
                    const realDistance = Math.sqrt(
                        Math.pow(this.mirror.x - this.object.x, 2) + 
                        Math.pow(this.mirror.y - this.object.y, 2)
                    );
                    const virtualDistance = Math.sqrt(
                        Math.pow(this.mirror.x - virtualPos.x, 2) + 
                        Math.pow(this.mirror.y - virtualPos.y, 2)
                    );
                    
                    // Ölçek faktörünü göz önünde bulundurarak mesafeleri düzelt
                    const scaleFactor = this.scale / 8;
                    document.getElementById('realDistance').textContent = (realDistance / scaleFactor).toFixed(1) + 'cm';
                    document.getElementById('virtualDistance').textContent = (virtualDistance / scaleFactor).toFixed(1) + 'cm';
                    
                } else {
                    document.getElementById('systemStatus').textContent = 'Uyarı';
                    document.getElementById('systemStatus').className = 'status-warning';
                    document.getElementById('imageStatus').textContent = 'Oluşmuyor';
                    document.getElementById('imageStatus').className = 'status-warning';
                    
                    document.getElementById('realDistance').textContent = '--cm';
                    document.getElementById('virtualDistance').textContent = '--cm';
                }
                
                // Diğer durum bilgileri
                const objectAngleDegrees = Math.round((this.object.rotation * 180) / Math.PI);
                document.getElementById('objectAngle').textContent = objectAngleDegrees + '°';
                
                const mirrorAngleDegrees = Math.round((this.mirror.angle * 180) / Math.PI);
                document.getElementById('mirrorAngleStatus').textContent = mirrorAngleDegrees + '°';
            }
            
            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        let simulation;
        
        function toggleExtensions() {
            simulation.showExtensions = !simulation.showExtensions;
            const btn = document.getElementById('showExtensions');
            btn.textContent = 'Uzantılar: ' + (simulation.showExtensions ? 'AÇIK' : 'KAPALI');
            btn.className = simulation.showExtensions ? 'active' : '';
        }
        
        function toggleRuler() {
            simulation.ruler.visible = !simulation.ruler.visible;
            const btn = document.getElementById('showRuler');
            btn.textContent = 'Cetvel: ' + (simulation.ruler.visible ? 'AÇIK' : 'KAPALI');
            btn.className = simulation.ruler.visible ? 'active' : '';
        }
        
        function toggleProtractor() {
            simulation.protractor.visible = !simulation.protractor.visible;
            const btn = document.getElementById('showProtractor');
            btn.textContent = 'Açı Ölçer: ' + (simulation.protractor.visible ? 'AÇIK' : 'KAPALI');
            btn.className = simulation.protractor.visible ? 'active' : '';
        }
        
        // Simülasyonu başlat
        window.addEventListener('load', () => {
            simulation = new ResponsiveMirrorSimulation();
        });
        
        // Mobil cihazlarda sayfa kaydırmayı engelle
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        // Zoom engelleme
        document.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
