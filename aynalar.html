<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tƒ±rtƒ±klƒ± Ayna - D√ºzlem Ayna Sim√ºlasyonu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
        }
        
        .simulation-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #ffffff, #f7fafc);
            cursor: grab;
            display: block;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .controls-overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 240px;
            z-index: 1000;
            max-height: calc(100vh - 30px);
            overflow-y: auto;
        }
        
        .control-section {
            margin-bottom: 15px;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .control-section h3 {
            font-size: 12px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.1);
            outline: none;
            appearance: none;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.6);
        }
        
        select, button {
            width: 100%;
            padding: 6px 8px;
            border-radius: 6px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #2d3748;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, select:focus {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 5px;
        }
        
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        button.active {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }
        
        .value-display {
            font-size: 9px;
            font-weight: 700;
            color: #2d3748;
            text-align: center;
            background: rgba(0, 0, 0, 0.05);
            padding: 3px 6px;
            border-radius: 4px;
            margin-top: 2px;
        }
        
        .info-overlay {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 280px;
            z-index: 1000;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
        }
        
        .info-section {
            margin-bottom: 15px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section h4 {
            font-size: 12px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .legend-item {
            font-size: 9px;
            color: #4a5568;
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-symbol {
            min-width: 16px;
            text-align: center;
            font-weight: bold;
        }
        
        .status-item {
            font-size: 10px;
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-label {
            color: #4a5568;
            font-weight: 600;
        }
        
        .status-value {
            color: #2d3748;
            font-weight: 700;
        }
        
        .status-warning {
            color: #e53e3e;
            font-weight: 700;
        }
        
        .measurement-control-group {
            margin-bottom: 8px;
        }
        
        .measurement-control-group:last-child {
            margin-bottom: 0;
        }
        
        .measurement-control-group label {
            display: block;
            font-size: 9px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        @media (max-width: 768px) {
            .controls-overlay,
            .info-overlay {
                max-width: 200px;
                padding: 10px;
                font-size: 8px;
            }
            
            .control-section h3,
            .info-section h4 {
                font-size: 10px;
            }
            
            .legend-item,
            .status-item {
                font-size: 8px;
            }
        }
        
        @media (max-width: 480px) {
            .controls-overlay {
                max-width: 160px;
                padding: 8px;
            }
            
            .info-overlay {
                max-width: 180px;
                max-height: calc(100vh - 200px);
            }
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <canvas id="mirrorCanvas"></canvas>
        
        <div class="controls-overlay">
            <div class="control-section">
                <h3>üéØ Cisim Ayarlarƒ±</h3>
                <div class="control-group">
                    <label for="objectType">Cisim T√ºr√º</label>
                    <select id="objectType">
                        <option value="circle">üî¥ Daire</option>
                        <option value="arrow" selected>üèπ Ok</option>
                        <option value="square">üü• Kare</option>
                        <option value="triangle">üî∫ √ú√ßgen</option>
                        <option value="letter_e">üìù E Harfi</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="objectSize">Boyut</label>
                    <input type="range" id="objectSize" min="2" max="8" value="4" step="0.5">
                    <div class="value-display" id="sizeValue">4.0 cm</div>
                </div>
                <div class="control-group">
                    <label for="objectRotation">D√∂nd√ºrme</label>
                    <input type="range" id="objectRotation" min="0" max="360" value="0" step="15">
                    <div class="value-display" id="rotationValue">0¬∞</div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ü™û Ayna Ayarlarƒ±</h3>
                <div class="control-group">
                    <label for="mirrorAngle">A√ßƒ±</label>
                    <input type="range" id="mirrorAngle" min="0" max="180" value="90" step="1">
                    <div class="value-display" id="angleValue">90¬∞</div>
                </div>
            </div>
        </div>
        
        <div class="info-overlay">
            <!-- YENƒ∞ SIRA: √ñl√ß√ºm Ara√ßlarƒ± √ñNCE -->
            <div class="info-section">
                <h4>üìê √ñl√ß√ºm Ara√ßlarƒ±</h4>
                <div class="measurement-control-group">
                    <label for="rulerLength">Cetvel Boyu</label>
                    <input type="range" id="rulerLength" min="10" max="40" value="25" step="2">
                    <div class="value-display" id="rulerLengthValue">25.0 cm</div>
                </div>
                <button id="showRuler" onclick="toggleRuler()">Cetvel: KAPALI</button>
                <button id="showProtractor" onclick="toggleProtractor()">A√ßƒ± √ñl√ßer: KAPALI</button>
                <button id="showExtensions" onclick="toggleExtensions()">Uzantƒ±lar: A√áIK</button>
            </div>
            
            <!-- YENƒ∞ SIRA: Sim√ºlasyon G√∂stergeleri ƒ∞Kƒ∞NCƒ∞ -->
            <div class="info-section">
                <h4>üìã Sim√ºlasyon G√∂stergeleri</h4>
                <div class="legend-item">
                    <span class="legend-symbol">üî¥</span>
                    <span>Ger√ßek Cisim (Hareket ettirilebilir)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üîµ</span>
                    <span>Sanal G√∂r√ºnt√º (Otomatik)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üü†</span>
                    <span>Gelen I≈üƒ±n (Y√∂n oklu)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üü¢</span>
                    <span>Yansƒ±yan I≈üƒ±n (Y√∂n oklu)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üü¢</span>
                    <span>I≈üƒ±n Uzantƒ±sƒ± (Kesikli √ßizgi)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">ü™û</span>
                    <span>D√ºzlem Ayna (Tƒ±rtƒ±klƒ± sol kenar)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üìè</span>
                    <span>Cetvel (Hareket ve d√∂nd√ºr)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üìê</span>
                    <span>A√ßƒ± √ñl√ßer (Hareket ve d√∂nd√ºr)</span>
                </div>
            </div>
            
            <!-- Durum Bilgileri √ú√á√úNC√ú -->
            <div class="info-section">
                <h4>üìä Durum Bilgileri</h4>
                <div class="status-item">
                    <span class="status-label">Sistem:</span>
                    <span class="status-value" id="systemStatus">Normal</span>
                </div>
                <div class="status-item">
                    <span class="status-label">G√∂r√ºnt√º:</span>
                    <span class="status-value" id="imageStatus">Olu≈üuyor</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Cisim mesafesi:</span>
                    <span class="status-value" id="realDistance">--</span>
                </div>
                <div class="status-item">
                    <span class="status-label">G√∂r√ºnt√º mesafesi:</span>
                    <span class="status-value" id="virtualDistance">--</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Cisim a√ßƒ±sƒ±:</span>
                    <span class="status-value" id="objectAngle">0¬∞</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Ayna a√ßƒ±sƒ±:</span>
                    <span class="status-value" id="mirrorAngleStatus">90¬∞</span>
                </div>
                <div class="status-item">
                    <span class="status-label">A√ßƒ± √∂l√ßer:</span>
                    <span class="status-value" id="protractorAngle">Kapalƒ±</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Uzantƒ±lar:</span>
                    <span class="status-value" id="extensionsStatus">A√ßƒ±k</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NotchedMirrorSimulation {
            constructor() {
                this.canvas = document.getElementById('mirrorCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Canvas boyutunu tam ekrana ayarla
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // √ñl√ßek: 1 cm = 8 piksel
                this.scale = 8;
                
                // Canvas merkezini hesapla
                this.centerX = this.pxToCm(this.canvas.width / 2);
                this.centerY = this.pxToCm(this.canvas.height / 2);
                
                // Cisim aynanƒ±n saƒüƒ±nda ba≈ülasƒ±n
                this.mirror = { 
                    x: this.centerX - 5,  // Ayna merkezden biraz solda
                    y: this.centerY,      // Merkez y√ºksekliƒüi  
                    length: 35,           // 35 cm uzunluk
                    angle: Math.PI / 2    // 90 derece (dikey)
                };
                
                this.object = { 
                    x: this.centerX + 30, // Cisim aynanƒ±n saƒüƒ±nda (merkez + 30cm)
                    y: this.centerY,      // Merkez y√ºksekliƒüi
                    size: 4,
                    type: 'arrow',
                    rotation: 0
                };
                
                this.ruler = {
                    x: this.centerX,
                    y: this.centerY + 25,
                    length: 25,
                    angle: 0,
                    visible: false
                };
                
                this.protractor = {
                    x: this.centerX - 10,
                    y: this.centerY - 15,
                    radius: 20,
                    angle: 0,
                    visible: false
                };
                
                // Sabit 2 ƒ±≈üƒ±n + uzantƒ±lar a√ßƒ±k
                this.rayCount = 2;
                this.showExtensions = true;
                this.isDragging = false;
                this.dragTarget = null;
                this.lastMouse = { x: 0, y: 0 };
                
                this.setupEventListeners();
                this.setupControls();
                this.animate();
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                if (this.canvas.width > 0 && this.canvas.height > 0) {
                    this.centerX = this.pxToCm(this.canvas.width / 2);
                    this.centerY = this.pxToCm(this.canvas.height / 2);
                }
            }
            
            cmToPx(cm) { return cm * this.scale; }
            pxToCm(px) { return px / this.scale; }
            
            isObjectInFrontOfMirror() {
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const objectToMirror = {
                    x: this.mirror.x - this.object.x,
                    y: this.mirror.y - this.object.y
                };
                
                const dotProduct = objectToMirror.x * mirrorNormal.x + objectToMirror.y * mirrorNormal.y;
                return dotProduct > 0;
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleEnd());
                this.canvas.addEventListener('mouseleave', () => this.handleEnd());
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleStart(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleMove(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleEnd();
                });
            }
            
            setupControls() {
                const controls = {
                    mirrorAngle: document.getElementById('mirrorAngle'),
                    angleValue: document.getElementById('angleValue'),
                    objectSize: document.getElementById('objectSize'),
                    sizeValue: document.getElementById('sizeValue'),
                    objectType: document.getElementById('objectType'),
                    objectRotation: document.getElementById('objectRotation'),
                    rotationValue: document.getElementById('rotationValue'),
                    rulerLength: document.getElementById('rulerLength'),
                    rulerLengthValue: document.getElementById('rulerLengthValue')
                };
                
                controls.mirrorAngle.addEventListener('input', (e) => {
                    this.mirror.angle = (e.target.value * Math.PI) / 180;
                    controls.angleValue.textContent = e.target.value + '¬∞';
                });
                
                controls.objectSize.addEventListener('input', (e) => {
                    this.object.size = parseFloat(e.target.value);
                    controls.sizeValue.textContent = e.target.value + ' cm';
                });
                
                controls.objectType.addEventListener('change', (e) => {
                    this.object.type = e.target.value;
                });
                
                controls.objectRotation.addEventListener('input', (e) => {
                    this.object.rotation = (parseFloat(e.target.value) * Math.PI) / 180;
                    controls.rotationValue.textContent = e.target.value + '¬∞';
                });
                
                controls.rulerLength.addEventListener('input', (e) => {
                    this.ruler.length = parseFloat(e.target.value);
                    controls.rulerLengthValue.textContent = e.target.value + ' cm';
                });
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: this.pxToCm(e.clientX - rect.left),
                    y: this.pxToCm(e.clientY - rect.top)
                };
            }
            
            handleStart(e) {
                const mouse = this.getMousePos(e);
                this.lastMouse = mouse;
                
                // Cisim kontrol√º
                const objDist = Math.sqrt(
                    Math.pow(mouse.x - this.object.x, 2) + 
                    Math.pow(mouse.y - this.object.y, 2)
                );
                
                if (objDist < this.object.size + 1) {
                    this.isDragging = true;
                    this.dragTarget = 'object';
                    return;
                }
                
                // Cetvel kontrol√º
                if (this.ruler.visible) {
                    const rulerDist = this.distanceToRuler(mouse);
                    if (rulerDist < 2) {
                        this.isDragging = true;
                        this.dragTarget = 'ruler';
                        this.rulerDragMode = this.isNearRulerEnd(mouse) ? 'rotate' : 'move';
                        return;
                    }
                }
                
                // A√ßƒ± √∂l√ßer kontrol√º
                if (this.protractor.visible) {
                    const protractorDist = Math.sqrt(
                        Math.pow(mouse.x - this.protractor.x, 2) + 
                        Math.pow(mouse.y - this.protractor.y, 2)
                    );
                    
                    if (protractorDist < this.protractor.radius + 2) {
                        this.isDragging = true;
                        this.dragTarget = 'protractor';
                        
                        if (protractorDist < 5) {
                            this.protractorDragMode = 'move';
                        } else {
                            this.protractorDragMode = 'rotate';
                        }
                        return;
                    }
                }
                
                // Ayna kontrol√º
                const mirrorStart = {
                    x: this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2,
                    y: this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2
                };
                const mirrorEnd = {
                    x: this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2,
                    y: this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2
                };
                
                const distToMirror = this.distanceToLine(mouse, mirrorStart, mirrorEnd);
                if (distToMirror < 2.5) {
                    this.isDragging = true;
                    this.dragTarget = 'mirror';
                    
                    const distToCenter = Math.sqrt(
                        Math.pow(mouse.x - this.mirror.x, 2) + 
                        Math.pow(mouse.y - this.mirror.y, 2)
                    );
                    
                    this.mirrorDragMode = distToCenter < 5 ? 'move' : 'rotate';
                }
            }
            
            isNearRulerEnd(point) {
                const endX = this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2;
                const endY = this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2;
                const distToEnd = Math.sqrt(
                    Math.pow(point.x - endX, 2) + Math.pow(point.y - endY, 2)
                );
                return distToEnd < 3;
            }
            
            handleMove(e) {
                if (!this.isDragging) return;
                
                const mouse = this.getMousePos(e);
                
                if (this.dragTarget === 'object') {
                    this.object.x = Math.max(this.object.size, 
                        Math.min(this.pxToCm(this.canvas.width) - this.object.size, mouse.x));
                    this.object.y = Math.max(this.object.size, 
                        Math.min(this.pxToCm(this.canvas.height) - this.object.size, mouse.y));
                        
                } else if (this.dragTarget === 'mirror') {
                    if (this.mirrorDragMode === 'move') {
                        this.mirror.x = Math.max(10, 
                            Math.min(this.pxToCm(this.canvas.width) - 10, mouse.x));
                        this.mirror.y = Math.max(10, 
                            Math.min(this.pxToCm(this.canvas.height) - 10, mouse.y));
                    } else {
                        const centerToMouse = Math.atan2(mouse.y - this.mirror.y, mouse.x - this.mirror.x);
                        this.mirror.angle = centerToMouse;
                        
                        const degrees = Math.round((this.mirror.angle * 180) / Math.PI);
                        const normalizedDegrees = ((degrees % 360) + 360) % 360;
                        document.getElementById('mirrorAngle').value = normalizedDegrees;
                        document.getElementById('angleValue').textContent = normalizedDegrees + '¬∞';
                    }
                    
                } else if (this.dragTarget === 'ruler') {
                    if (this.rulerDragMode === 'move') {
                        this.ruler.x = mouse.x;
                        this.ruler.y = mouse.y;
                    } else if (this.rulerDragMode === 'rotate') {
                        const centerToMouse = Math.atan2(mouse.y - this.ruler.y, mouse.x - this.ruler.x);
                        this.ruler.angle = centerToMouse;
                    }
                    
                } else if (this.dragTarget === 'protractor') {
                    if (this.protractorDragMode === 'move') {
                        this.protractor.x = Math.max(this.protractor.radius, 
                            Math.min(this.pxToCm(this.canvas.width) - this.protractor.radius, mouse.x));
                        this.protractor.y = Math.max(this.protractor.radius, 
                            Math.min(this.pxToCm(this.canvas.height) - this.protractor.radius, mouse.y));
                    } else if (this.protractorDragMode === 'rotate') {
                        const centerToMouse = Math.atan2(mouse.y - this.protractor.y, mouse.x - this.protractor.x);
                        this.protractor.angle = centerToMouse;
                    }
                }
                
                this.lastMouse = mouse;
            }
            
            handleEnd() {
                this.isDragging = false;
                this.dragTarget = null;
                this.rulerDragMode = null;
                this.mirrorDragMode = null;
                this.protractorDragMode = null;
            }
            
            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            distanceToRuler(point) {
                const rulerStart = {
                    x: this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2,
                    y: this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2
                };
                const rulerEnd = {
                    x: this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2,
                    y: this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2
                };
                
                return this.distanceToLine(point, rulerStart, rulerEnd);
            }
            
            calculateReflection(incident, normal) {
                const dot = incident.x * normal.x + incident.y * normal.y;
                return {
                    x: incident.x - 2 * dot * normal.x,
                    y: incident.y - 2 * dot * normal.y
                };
            }
            
            getVirtualImage() {
                if (!this.isObjectInFrontOfMirror()) {
                    return null;
                }
                
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const toMirror = {
                    x: this.mirror.x - this.object.x,
                    y: this.mirror.y - this.object.y
                };
                
                const normalDist = toMirror.x * mirrorNormal.x + toMirror.y * mirrorNormal.y;
                
                return {
                    x: this.object.x + 2 * normalDist * mirrorNormal.x,
                    y: this.object.y + 2 * normalDist * mirrorNormal.y
                };
            }
            
            lineIntersection(p1, p2, p3, p4) {
                const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                if (Math.abs(denom) < 0.001) return null;
                
                const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
                const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;
                
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return null;
            }
            
            // Ok √ßizme fonksiyonu
            drawArrow(fromX, fromY, toX, toY, color, lineWidth = 3) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length < 10) return;
                
                const unitX = dx / length;
                const unitY = dy / length;
                
                const arrowPos = 0.85;
                const arrowX = fromX + dx * arrowPos;
                const arrowY = fromY + dy * arrowPos;
                
                const arrowSize = Math.min(15, length * 0.15);
                const arrowAngle = Math.PI / 6;
                
                const leftWingX = arrowX - (unitX * Math.cos(arrowAngle) - unitY * Math.sin(arrowAngle)) * arrowSize;
                const leftWingY = arrowY - (unitX * Math.sin(arrowAngle) + unitY * Math.cos(arrowAngle)) * arrowSize;
                
                const rightWingX = arrowX - (unitX * Math.cos(-arrowAngle) - unitY * Math.sin(-arrowAngle)) * arrowSize;
                const rightWingY = arrowY - (unitX * Math.sin(-arrowAngle) + unitY * Math.cos(-arrowAngle)) * arrowSize;
                
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(fromX, fromY);
                this.ctx.lineTo(toX, toY);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(leftWingX, leftWingY);
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(rightWingX, rightWingY);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(leftWingX, leftWingY);
                this.ctx.lineTo(rightWingX, rightWingY);
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGrid();
                this.drawMirror();
                this.drawObject();
                
                if (this.isObjectInFrontOfMirror()) {
                    this.drawVirtualImage();
                    this.drawRays();
                }
                
                if (this.ruler.visible) {
                    this.drawRuler();
                }
                
                if (this.protractor.visible) {
                    this.drawProtractor();
                }
                
                this.updateStatus();
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(100, 116, 139, 0.1)';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x < this.canvas.width; x += this.cmToPx(5)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += this.cmToPx(5)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                this.ctx.strokeStyle = 'rgba(100, 116, 139, 0.05)';
                for (let x = 0; x < this.canvas.width; x += this.cmToPx(1)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += this.cmToPx(1)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            // Tƒ±rtƒ±klƒ± ayna √ßizme fonksiyonu
            drawMirror() {
                const startX = this.cmToPx(this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2);
                const startY = this.cmToPx(this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2);
                const endX = this.cmToPx(this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2);
                const endY = this.cmToPx(this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2);
                
                // Ayna y√ºzeyi
                const gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, '#E2E8F0');
                gradient.addColorStop(0.3, '#CBD5E0');
                gradient.addColorStop(0.7, '#A0AEC0');
                gradient.addColorStop(1, '#718096');
                
                this.ctx.strokeStyle = gradient;
                this.ctx.lineWidth = 16;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Ayna kenarƒ±
                this.ctx.strokeStyle = '#2D3748';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Sol tarafa tƒ±rtƒ±k ekleme
                this.drawMirrorNotches(startX, startY, endX, endY);
                
                // Merkez tutacaƒüƒ±
                this.ctx.fillStyle = '#667EEA';
                this.ctx.beginPath();
                this.ctx.arc(this.cmToPx(this.mirror.x), this.cmToPx(this.mirror.y), 8, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#4C51BF';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Normal √ßizgisi
                this.ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                const normalStartX = this.cmToPx(this.mirror.x);
                const normalStartY = this.cmToPx(this.mirror.y);
                const normalEndX = this.cmToPx(this.mirror.x - Math.sin(this.mirror.angle) * 8);
                const normalEndY = this.cmToPx(this.mirror.y + Math.cos(this.mirror.angle) * 8);
                
                this.ctx.beginPath();
                this.ctx.moveTo(normalStartX, normalStartY);
                this.ctx.lineTo(normalEndX, normalEndY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            // Ayna tƒ±rtƒ±k √ßizme fonksiyonu
            drawMirrorNotches(startX, startY, endX, endY) {
                const mirrorLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const unitX = (endX - startX) / mirrorLength;
                const unitY = (endY - startY) / mirrorLength;
                
                // Sol taraf normal vekt√∂r√º
                const leftNormalX = -unitY;
                const leftNormalY = unitX;
                
                // Tƒ±rtƒ±k parametreleri
                const notchSpacing = this.cmToPx(2); // 2 cm aralƒ±k
                const notchLength = 8; // 8 piksel uzunluk
                const notchCount = Math.floor(mirrorLength / notchSpacing);
                
                this.ctx.strokeStyle = '#2D3748';
                this.ctx.lineWidth = 2;
                
                for (let i = 1; i < notchCount; i++) {
                    const t = i / notchCount;
                    const notchX = startX + t * (endX - startX);
                    const notchY = startY + t * (endY - startY);
                    
                    const notchEndX = notchX + leftNormalX * notchLength;
                    const notchEndY = notchY + leftNormalY * notchLength;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(notchX, notchY);
                    this.ctx.lineTo(notchEndX, notchEndY);
                    this.ctx.stroke();
                }
            }
            
            drawObject() {
                const x = this.cmToPx(this.object.x);
                const y = this.cmToPx(this.object.y);
                const size = this.cmToPx(this.object.size);
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, '#FC8181');
                gradient.addColorStop(1, '#E53E3E');
                
                this.ctx.fillStyle = gradient;
                this.ctx.strokeStyle = '#C53030';
                this.ctx.lineWidth = 3;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(this.object.rotation);
                
                switch(this.object.type) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, 0);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.lineTo(size * 0.2, -size * 0.6);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(size * 0.2, size * 0.6);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-size, -size, size * 2, size * 2);
                        this.ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                        
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(-size, size);
                        this.ctx.lineTo(size, size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'letter_e':
                        const lineWidth = size * 0.15;
                        this.ctx.lineWidth = lineWidth;
                        this.ctx.strokeStyle = '#C53030';
                        this.ctx.fillStyle = gradient;
                        
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, lineWidth, size * 1.6);
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, size * 1.4, lineWidth);
                        this.ctx.fillRect(-size * 0.8, -lineWidth/2, size * 1.2, lineWidth);
                        this.ctx.fillRect(-size * 0.8, size * 0.8 - lineWidth, size * 1.4, lineWidth);
                        break;
                }
                
                this.ctx.restore();
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawVirtualImage() {
                const virtualPos = this.getVirtualImage();
                if (!virtualPos) return;
                
                const x = this.cmToPx(virtualPos.x);
                const y = this.cmToPx(virtualPos.y);
                const size = this.cmToPx(this.object.size);
                
                this.ctx.setLineDash([10, 10]);
                this.ctx.strokeStyle = '#667EEA';
                this.ctx.lineWidth = 3;
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.4)');
                gradient.addColorStop(1, 'rgba(102, 126, 234, 0.2)');
                this.ctx.fillStyle = gradient;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(-this.object.rotation);
                
                switch(this.object.type) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.ctx.scale(-1, 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, 0);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.lineTo(size * 0.2, -size * 0.6);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(size * 0.2, size * 0.6);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-size, -size, size * 2, size * 2);
                        this.ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                        
                    case 'triangle':
                        this.ctx.scale(-1, 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(-size, size);
                        this.ctx.lineTo(size, size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'letter_e':
                        this.ctx.scale(-1, 1);
                        const lineWidth = size * 0.15;
                        
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, lineWidth, size * 1.6);
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, size * 1.4, lineWidth);
                        this.ctx.fillRect(-size * 0.8, -lineWidth/2, size * 1.2, lineWidth);
                        this.ctx.fillRect(-size * 0.8, size * 0.8 - lineWidth, size * 1.4, lineWidth);
                        break;
                }
                
                this.ctx.restore();
                this.ctx.setLineDash([]);
                
                this.ctx.fillStyle = '#667EEA';
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawRays() {
                if (!this.isObjectInFrontOfMirror()) return;
                
                const mirrorStartX = this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2;
                const mirrorStartY = this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2;
                const mirrorEndX = this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2;
                const mirrorEndY = this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2;
                
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const virtualPos = this.getVirtualImage();
                const rayAngles = [Math.PI * 0.25, Math.PI * 1.75];
                
                for (let i = 0; i < this.rayCount; i++) {
                    const angle = rayAngles[i];
                    const rayStartX = this.object.x + Math.cos(angle) * this.object.size * 0.8;
                    const rayStartY = this.object.y + Math.sin(angle) * this.object.size * 0.8;
                    
                    const toMirrorX = this.mirror.x - rayStartX;
                    const toMirrorY = this.mirror.y - rayStartY;
                    const length = Math.sqrt(toMirrorX * toMirrorX + toMirrorY * toMirrorY);
                    const dirX = toMirrorX / length;
                    const dirY = toMirrorY / length;
                    
                    const rayEnd = {
                        x: rayStartX + dirX * 120,
                        y: rayStartY + dirY * 120
                    };
                    
                    const intersection = this.lineIntersection(
                        { x: rayStartX, y: rayStartY },
                        rayEnd,
                        { x: mirrorStartX, y: mirrorStartY },
                        { x: mirrorEndX, y: mirrorEndY }
                    );
                    
                    if (intersection) {
                        // Gelen ƒ±≈üƒ±n
                        this.drawArrow(
                            this.cmToPx(rayStartX), 
                            this.cmToPx(rayStartY),
                            this.cmToPx(intersection.x), 
                            this.cmToPx(intersection.y),
                            '#F39C12', 
                            4
                        );
                        
                        // Yansƒ±yan ƒ±≈üƒ±n
                        const incident = { x: dirX, y: dirY };
                        const reflected = this.calculateReflection(incident, mirrorNormal);
                        
                        const reflectedEndX = intersection.x + reflected.x * 25;
                        const reflectedEndY = intersection.y + reflected.y * 25;
                        
                        this.drawArrow(
                            this.cmToPx(intersection.x), 
                            this.cmToPx(intersection.y),
                            this.cmToPx(reflectedEndX), 
                            this.cmToPx(reflectedEndY),
                            '#27AE60', 
                            4
                        );
                        
                        // Uzantƒ±lar g√∂r√ºnt√ºye kadar
                        if (this.showExtensions && virtualPos) {
                            const extensionEndX = virtualPos.x + Math.cos(angle) * this.object.size * 0.8;
                            const extensionEndY = virtualPos.y + Math.sin(angle) * this.object.size * 0.8;
                            
                            this.ctx.strokeStyle = 'rgba(39, 174, 96, 0.6)';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([10, 10]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.cmToPx(intersection.x), this.cmToPx(intersection.y));
                            this.ctx.lineTo(this.cmToPx(extensionEndX), this.cmToPx(extensionEndY));
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                        }
                        
                        // Kesi≈üim noktasƒ±
                        this.ctx.fillStyle = '#F1C40F';
                        this.ctx.beginPath();
                        this.ctx.arc(this.cmToPx(intersection.x), this.cmToPx(intersection.y), 6, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        this.ctx.strokeStyle = '#D68910';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }
            }
            
            drawRuler() {
                const startX = this.cmToPx(this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2);
                const startY = this.cmToPx(this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2);
                const endX = this.cmToPx(this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2);
                const endY = this.cmToPx(this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2);
                
                this.ctx.strokeStyle = '#8D6E63';
                this.ctx.lineWidth = 8;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                this.ctx.strokeStyle = '#5D4037';
                this.ctx.lineWidth = 1;
                this.ctx.font = '10px Arial';
                this.ctx.fillStyle = '#3E2723';
                this.ctx.textAlign = 'center';
                
                const normalX = -Math.sin(this.ruler.angle);
                const normalY = Math.cos(this.ruler.angle);
                
                for (let i = 0; i <= this.ruler.length; i += 1) {
                    const x = this.cmToPx(this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2 + Math.cos(this.ruler.angle) * i);
                    const y = this.cmToPx(this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2 + Math.sin(this.ruler.angle) * i);
                    
                    const markLength = (i % 5 === 0) ? 12 : 8;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y);
                    this.ctx.lineTo(x + normalX * markLength, y + normalY * markLength);
                    this.ctx.stroke();
                    
                    if (i % 5 === 0) {
                        this.ctx.save();
                        this.ctx.translate(x + normalX * 16, y + normalY * 16);
                        this.ctx.rotate(this.ruler.angle);
                        this.ctx.fillText(i + 'cm', 0, 0);
                        this.ctx.restore();
                    }
                }
                
                this.ctx.fillStyle = '#FF5722';
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawProtractor() {
                const centerX = this.cmToPx(this.protractor.x);
                const centerY = this.cmToPx(this.protractor.y);
                const radius = this.cmToPx(this.protractor.radius);
                
                // A√ßƒ± √∂l√ßer g√∂vdesi (yarƒ±m daire)
                this.ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                this.ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';
                this.ctx.lineWidth = 3;
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI, false);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                // A√ßƒ± √ßizgileri
                this.ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';
                this.ctx.lineWidth = 1;
                this.ctx.font = '8px Arial';
                this.ctx.fillStyle = '#B8860B';
                this.ctx.textAlign = 'center';
                
                for (let angle = 0; angle <= 180; angle += 10) {
                    const radian = (angle * Math.PI) / 180 + this.protractor.angle;
                    const lineLength = (angle % 30 === 0) ? radius * 0.8 : radius * 0.9;
                    
                    const startX = centerX + Math.cos(radian) * lineLength;
                    const startY = centerY + Math.sin(radian) * lineLength;
                    const endX = centerX + Math.cos(radian) * radius;
                    const endY = centerY + Math.sin(radian) * radius;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                    this.ctx.stroke();
                    
                    // A√ßƒ± deƒüerleri
                    if (angle % 30 === 0) {
                        const textX = centerX + Math.cos(radian) * (radius * 0.7);
                        const textY = centerY + Math.sin(radian) * (radius * 0.7);
                        
                        this.ctx.save();
                        this.ctx.translate(textX, textY);
                        this.ctx.rotate(radian - Math.PI/2);
                        this.ctx.fillText(angle + '¬∞', 0, 0);
                        this.ctx.restore();
                    }
                }
                
                // Merkez noktasƒ±
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // D√∂nd√ºrme tutacaƒüƒ±
                const handleX = centerX + Math.cos(this.protractor.angle + Math.PI) * radius * 0.8;
                const handleY = centerY + Math.sin(this.protractor.angle + Math.PI) * radius * 0.8;
                
                this.ctx.fillStyle = '#FF4500';
                this.ctx.beginPath();
                this.ctx.arc(handleX, handleY, 8, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            updateStatus() {
                if (this.isObjectInFrontOfMirror()) {
                    document.getElementById('systemStatus').textContent = 'Normal';
                    document.getElementById('systemStatus').className = 'status-value';
                    document.getElementById('imageStatus').textContent = 'Olu≈üuyor';
                    document.getElementById('imageStatus').className = 'status-value';
                    
                    const virtualPos = this.getVirtualImage();
                    const realDistance = Math.sqrt(
                        Math.pow(this.mirror.x - this.object.x, 2) + 
                        Math.pow(this.mirror.y - this.object.y, 2)
                    );
                    const virtualDistance = Math.sqrt(
                        Math.pow(this.mirror.x - virtualPos.x, 2) + 
                        Math.pow(this.mirror.y - virtualPos.y, 2)
                    );
                    
                    document.getElementById('realDistance').textContent = realDistance.toFixed(1) + ' cm';
                    document.getElementById('virtualDistance').textContent = virtualDistance.toFixed(1) + ' cm';
                    
                } else {
                    document.getElementById('systemStatus').textContent = 'Uyarƒ±';
                    document.getElementById('systemStatus').className = 'status-warning';
                    document.getElementById('imageStatus').textContent = 'Olu≈ümuyor';
                    document.getElementById('imageStatus').className = 'status-warning';
                    
                    document.getElementById('realDistance').textContent = '√ñl√ß√ºlemiyor';
                    document.getElementById('virtualDistance').textContent = 'Yok';
                }
                
                // Diƒüer durum bilgileri
                const objectAngleDegrees = Math.round((this.object.rotation * 180) / Math.PI);
                document.getElementById('objectAngle').textContent = objectAngleDegrees + '¬∞';
                
                const mirrorAngleDegrees = Math.round((this.mirror.angle * 180) / Math.PI);
                document.getElementById('mirrorAngleStatus').textContent = mirrorAngleDegrees + '¬∞';
                
                if (this.protractor.visible) {
                    const protractorAngleDegrees = Math.round((this.protractor.angle * 180) / Math.PI);
                    document.getElementById('protractorAngle').textContent = protractorAngleDegrees + '¬∞';
                } else {
                    document.getElementById('protractorAngle').textContent = 'Kapalƒ±';
                }
                
                document.getElementById('extensionsStatus').textContent = this.showExtensions ? 'A√ßƒ±k' : 'Kapalƒ±';
            }
            
            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        let simulation;
        
        function toggleExtensions() {
            simulation.showExtensions = !simulation.showExtensions;
            const btn = document.getElementById('showExtensions');
            btn.textContent = 'Uzantƒ±lar: ' + (simulation.showExtensions ? 'A√áIK' : 'KAPALI');
            btn.className = simulation.showExtensions ? 'active' : '';
        }
        
        function toggleRuler() {
            simulation.ruler.visible = !simulation.ruler.visible;
            const btn = document.getElementById('showRuler');
            btn.textContent = 'Cetvel: ' + (simulation.ruler.visible ? 'A√áIK' : 'KAPALI');
            btn.className = simulation.ruler.visible ? 'active' : '';
        }
        
        function toggleProtractor() {
            simulation.protractor.visible = !simulation.protractor.visible;
            const btn = document.getElementById('showProtractor');
            btn.textContent = 'A√ßƒ± √ñl√ßer: ' + (simulation.protractor.visible ? 'A√áIK' : 'KAPALI');
            btn.className = simulation.protractor.visible ? 'active' : '';
        }
        
        // Sim√ºlasyonu ba≈ülat
        window.addEventListener('load', () => {
            simulation = new NotchedMirrorSimulation();
        });
    </script>
</body>
</html>
