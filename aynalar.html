<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>D√ºzlem Ayna Sim√ºlasyonu - Mobil Uyumlu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1a1a1a;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
            touch-action: manipulation;
        }
        
        .simulation-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #ffffff, #f7fafc);
            cursor: grab;
            display: block;
            touch-action: none;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        /* Mobil optimized controls */
        .controls-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: min(280px, calc(100vw - 20px));
            z-index: 1000;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            transform: translateZ(0);
            -webkit-overflow-scrolling: touch;
        }
        
        .controls-toggle {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
        }
        
        .controls-toggle:hover {
            transform: scale(1.1);
        }
        
        .controls-overlay.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        
        .control-section {
            margin-bottom: 12px;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .control-section h3 {
            font-size: clamp(11px, 2.5vw, 13px);
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            display: block;
            font-size: clamp(9px, 2vw, 11px);
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        /* Touch-friendly sliders */
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.1);
            outline: none;
            appearance: none;
            margin-bottom: 4px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            transition: all 0.2s ease;
            border: 2px solid white;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover,
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }
        
        /* Touch-friendly buttons and selects */
        select, button {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #2d3748;
            font-size: clamp(10px, 2.2vw, 12px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Apple's recommended touch target */
            touch-action: manipulation;
        }
        
        select:hover, select:focus,
        button:hover, button:focus {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 4px;
        }
        
        button:hover, button:active {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
        }
        
        button.active {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }
        
        .value-display {
            font-size: clamp(8px, 1.8vw, 10px);
            font-weight: 700;
            color: #2d3748;
            text-align: center;
            background: rgba(0, 0, 0, 0.05);
            padding: 4px 8px;
            border-radius: 4px;
            margin-top: 2px;
        }
        
        /* Info panel - collapsible on mobile */
        .info-overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: min(300px, calc(100vw - 20px));
            z-index: 1000;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            transform: translateZ(0);
            -webkit-overflow-scrolling: touch;
        }
        
        .info-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
        }
        
        .info-overlay.hidden {
            transform: translateX(100%);
            opacity: 0;
            pointer-events: none;
        }
        
        .info-section {
            margin-bottom: 12px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section h4 {
            font-size: clamp(11px, 2.5vw, 13px);
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .legend-item {
            font-size: clamp(8px, 2vw, 10px);
            color: #4a5568;
            margin: 3px 0;
            display: flex;
            align-items: center;
            gap: 6px;
            line-height: 1.3;
        }
        
        .legend-symbol {
            min-width: 16px;
            text-align: center;
            font-weight: bold;
        }
        
        .status-item {
            font-size: clamp(9px, 2vw, 11px);
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }
        
        .status-label {
            color: #4a5568;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .status-value {
            color: #2d3748;
            font-weight: 700;
            text-align: right;
        }
        
        .status-warning {
            color: #e53e3e;
            font-weight: 700;
        }
        
        /* Responsive breakpoints */
        @media (max-width: 768px) {
            .controls-overlay,
            .info-overlay {
                max-width: calc(100vw - 80px);
                padding: 10px;
            }
            
            .controls-overlay {
                left: 60px;
            }
            
            .info-overlay {
                right: 60px;
            }
        }
        
        @media (max-width: 480px) {
            .controls-overlay {
                max-width: calc(100vw - 20px);
                left: 10px;
                right: 10px;
                top: auto;
                bottom: 10px;
                max-height: 40vh;
            }
            
            .controls-toggle {
                top: auto;
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .info-overlay {
                max-width: calc(100vw - 20px);
                left: 10px;
                right: 10px;
                top: 10px;
                max-height: 40vh;
            }
            
            .info-toggle {
                top: 60px;
                right: 15px;
            }
            
            .controls-overlay.hidden {
                transform: translateY(100%);
            }
            
            .info-overlay.hidden {
                transform: translateY(-100%);
            }
        }
        
        @media (max-width: 320px) {
            .control-section h3,
            .info-section h4 {
                font-size: 10px;
            }
            
            .legend-item,
            .status-item {
                font-size: 8px;
            }
        }
        
        /* Performance optimizations */
        .simulation-container,
        .controls-overlay,
        .info-overlay {
            will-change: transform;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .controls-overlay,
            .info-overlay {
                background: rgba(45, 55, 72, 0.95);
                color: #e2e8f0;
            }
            
            .control-section h3,
            .info-section h4 {
                color: #e2e8f0;
            }
            
            .status-label,
            .legend-item {
                color: #a0aec0;
            }
            
            .status-value {
                color: #e2e8f0;
            }
            
            select, button {
                background: rgba(45, 55, 72, 0.9);
                color: #e2e8f0;
            }
        }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <canvas id="mirrorCanvas" aria-label="D√ºzlem ayna sim√ºlasyonu"></canvas>
        
        <!-- Controls toggle button -->
        <div class="controls-toggle" onclick="toggleControls()" aria-label="Kontrolleri a√ß/kapat">
            ‚öôÔ∏è
        </div>
        
        <!-- Mobile optimized controls -->
        <div class="controls-overlay" id="controlsPanel">
            <div class="control-section">
                <h3>üéØ Cisim Ayarlarƒ±</h3>
                <div class="control-group">
                    <label for="objectType">Cisim T√ºr√º</label>
                    <select id="objectType" aria-label="Cisim t√ºr√º se√ßimi">
                        <option value="circle">üî¥ Daire</option>
                        <option value="arrow" selected>üèπ Ok</option>
                        <option value="square">üü• Kare</option>
                        <option value="triangle">üî∫ √ú√ßgen</option>
                        <option value="letter_e">üìù E Harfi</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="objectSize">Boyut</label>
                    <input type="range" id="objectSize" min="2" max="8" value="4" step="0.5" aria-label="Cisim boyutu">
                    <div class="value-display" id="sizeValue">4.0 cm</div>
                </div>
                <div class="control-group">
                    <label for="objectRotation">D√∂nd√ºrme</label>
                    <input type="range" id="objectRotation" min="0" max="360" value="0" step="15" aria-label="Cisim d√∂nd√ºrme a√ßƒ±sƒ±">
                    <div class="value-display" id="rotationValue">0¬∞</div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ü™û Ayna Ayarlarƒ±</h3>
                <div class="control-group">
                    <label for="mirrorAngle">A√ßƒ±</label>
                    <input type="range" id="mirrorAngle" min="0" max="180" value="90" step="1" aria-label="Ayna a√ßƒ±sƒ±">
                    <div class="value-display" id="angleValue">90¬∞</div>
                </div>
            </div>
        </div>
        
        <!-- Info toggle button -->
        <div class="info-toggle" onclick="toggleInfo()" aria-label="Bilgi panelini a√ß/kapat">
            ‚ÑπÔ∏è
        </div>
        
        <!-- Mobile optimized info panel -->
        <div class="info-overlay" id="infoPanel">
            <div class="info-section">
                <h4>üìê √ñl√ß√ºm Ara√ßlarƒ±</h4>
                <div class="control-group">
                    <label for="rulerLength">Cetvel Boyu</label>
                    <input type="range" id="rulerLength" min="10" max="40" value="25" step="2" aria-label="Cetvel uzunluƒüu">
                    <div class="value-display" id="rulerLengthValue">25.0 cm</div>
                </div>
                <button id="showRuler" onclick="toggleRuler()" aria-label="Cetveli g√∂ster/gizle">Cetvel: KAPALI</button>
                <button id="showProtractor" onclick="toggleProtractor()" aria-label="A√ßƒ± √∂l√ßeri g√∂ster/gizle">A√ßƒ± √ñl√ßer: KAPALI</button>
                <button id="showExtensions" onclick="toggleExtensions()" aria-label="I≈üƒ±n uzantƒ±larƒ±nƒ± g√∂ster/gizle">Uzantƒ±lar: A√áIK</button>
            </div>
            
            <div class="info-section">
                <h4>üìã G√∂stergeler</h4>
                <div class="legend-item">
                    <span class="legend-symbol">üî¥</span>
                    <span>Ger√ßek Cisim</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üîµ</span>
                    <span>Sanal G√∂r√ºnt√º</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üü†</span>
                    <span>Gelen I≈üƒ±n</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">üü¢</span>
                    <span>Yansƒ±yan I≈üƒ±n</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">ü™û</span>
                    <span>D√ºzlem Ayna</span>
                </div>
            </div>
            
            <div class="info-section">
                <h4>üìä Durum</h4>
                <div class="status-item">
                    <span class="status-label">Sistem:</span>
                    <span class="status-value" id="systemStatus">Normal</span>
                </div>
                <div class="status-item">
                    <span class="status-label">G√∂r√ºnt√º:</span>
                    <span class="status-value" id="imageStatus">Olu≈üuyor</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Cisim:</span>
                    <span class="status-value" id="realDistance">--</span>
                </div>
                <div class="status-item">
                    <span class="status-label">G√∂r√ºnt√º:</span>
                    <span class="status-value" id="virtualDistance">--</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class MobileOptimizedMirrorSimulation {
            constructor() {
                this.canvas = document.getElementById('mirrorCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Mobile performance settings
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.scale = this.isMobile ? 6 : 8; // Reduced scale for mobile performance
                this.animationId = null;
                this.lastFrameTime = 0;
                this.targetFPS = this.isMobile ? 30 : 60;
                this.frameInterval = 1000 / this.targetFPS;
                
                // Canvas setup
                this.resizeCanvas();
                window.addEventListener('resize', this.debounce(() => this.resizeCanvas(), 100));
                
                // Simulation state
                this.centerX = this.pxToCm(this.canvas.width / 2);
                this.centerY = this.pxToCm(this.canvas.height / 2);
                
                this.mirror = { 
                    x: this.centerX - 5,
                    y: this.centerY,
                    length: 35,
                    angle: Math.PI / 2
                };
                
                this.object = { 
                    x: this.centerX + 30,
                    y: this.centerY,
                    size: 4,
                    type: 'arrow',
                    rotation: 0
                };
                
                this.ruler = {
                    x: this.centerX,
                    y: this.centerY + 25,
                    length: 25,
                    angle: 0,
                    visible: false
                };
                
                this.protractor = {
                    x: this.centerX - 10,
                    y: this.centerY - 15,
                    radius: 20,
                    angle: 0,
                    visible: false
                };
                
                this.rayCount = 2;
                this.showExtensions = true;
                this.isDragging = false;
                this.dragTarget = null;
                this.lastTouch = { x: 0, y: 0 };
                this.touchStartTime = 0;
                this.isLongPress = false;
                
                this.setupEventListeners();
                this.setupControls();
                this.animate();
            }
            
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            resizeCanvas() {
                const devicePixelRatio = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                
                this.canvas.width = rect.width * devicePixelRatio;
                this.canvas.height = rect.height * devicePixelRatio;
                
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                if (this.canvas.width > 0 && this.canvas.height > 0) {
                    this.centerX = this.pxToCm(rect.width / 2);
                    this.centerY = this.pxToCm(rect.height / 2);
                }
            }
            
            cmToPx(cm) { return cm * this.scale; }
            pxToCm(px) { return px / this.scale; }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleEnd());
                this.canvas.addEventListener('mouseleave', () => this.handleEnd());
                
                // Touch events with improved handling
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchStartTime = Date.now();
                    this.isLongPress = false;
                    
                    // Long press detection for context menu
                    setTimeout(() => {
                        if (this.isDragging) {
                            this.isLongPress = true;
                            navigator.vibrate && navigator.vibrate(50);
                        }
                    }, 500);
                    
                    this.handleStart(e.touches[0]);
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleMove(e.touches[0]);
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touchDuration = Date.now() - this.touchStartTime;
                    
                    // Handle tap vs drag
                    if (touchDuration < 200 && !this.isDragging) {
                        // Quick tap - could implement context actions
                    }
                    
                    this.handleEnd();
                }, { passive: false });
                
                this.canvas.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleEnd();
                });
                
                // Prevent default zoom on double tap
                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length > 1) {
                        e.preventDefault();
                    }
                });
                
                // Handle device orientation change
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.resizeCanvas(), 100);
                });
            }
            
            setupControls() {
                const controls = {
                    mirrorAngle: document.getElementById('mirrorAngle'),
                    angleValue: document.getElementById('angleValue'),
                    objectSize: document.getElementById('objectSize'),
                    sizeValue: document.getElementById('sizeValue'),
                    objectType: document.getElementById('objectType'),
                    objectRotation: document.getElementById('objectRotation'),
                    rotationValue: document.getElementById('rotationValue'),
                    rulerLength: document.getElementById('rulerLength'),
                    rulerLengthValue: document.getElementById('rulerLengthValue')
                };
                
                // Enhanced control handlers with haptic feedback
                controls.mirrorAngle.addEventListener('input', (e) => {
                    this.mirror.angle = (e.target.value * Math.PI) / 180;
                    controls.angleValue.textContent = e.target.value + '¬∞';
                    this.hapticFeedback();
                });
                
                controls.objectSize.addEventListener('input', (e) => {
                    this.object.size = parseFloat(e.target.value);
                    controls.sizeValue.textContent = e.target.value + ' cm';
                    this.hapticFeedback();
                });
                
                controls.objectType.addEventListener('change', (e) => {
                    this.object.type = e.target.value;
                    this.hapticFeedback();
                });
                
                controls.objectRotation.addEventListener('input', (e) => {
                    this.object.rotation = (parseFloat(e.target.value) * Math.PI) / 180;
                    controls.rotationValue.textContent = e.target.value + '¬∞';
                    this.hapticFeedback();
                });
                
                controls.rulerLength.addEventListener('input', (e) => {
                    this.ruler.length = parseFloat(e.target.value);
                    controls.rulerLengthValue.textContent = e.target.value + ' cm';
                    this.hapticFeedback();
                });
            }
            
            hapticFeedback() {
                if (navigator.vibrate && this.isMobile) {
                    navigator.vibrate(10);
                }
            }
            
            getPointerPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: this.pxToCm(e.clientX - rect.left),
                    y: this.pxToCm(e.clientY - rect.top)
                };
            }
            
            handleStart(e) {
                const pos = this.getPointerPos(e);
                this.lastTouch = pos;
                
                // Increased touch tolerance for mobile
                const touchTolerance = this.isMobile ? 3 : 1;
                
                // Object detection
                const objDist = Math.sqrt(
                    Math.pow(pos.x - this.object.x, 2) + 
                    Math.pow(pos.y - this.object.y, 2)
                );
                
                if (objDist < this.object.size + touchTolerance) {
                    this.isDragging = true;
                    this.dragTarget = 'object';
                    this.hapticFeedback();
                    return;
                }
                
                // Ruler detection
                if (this.ruler.visible) {
                    const rulerDist = this.distanceToRuler(pos);
                    if (rulerDist < 2 + touchTolerance) {
                        this.isDragging = true;
                        this.dragTarget = 'ruler';
                        this.rulerDragMode = this.isNearRulerEnd(pos) ? 'rotate' : 'move';
                        this.hapticFeedback();
                        return;
                    }
                }
                
                // Protractor detection
                if (this.protractor.visible) {
                    const protractorDist = Math.sqrt(
                        Math.pow(pos.x - this.protractor.x, 2) + 
                        Math.pow(pos.y - this.protractor.y, 2)
                    );
                    
                    if (protractorDist < this.protractor.radius + touchTolerance) {
                        this.isDragging = true;
                        this.dragTarget = 'protractor';
                        this.protractorDragMode = protractorDist < 5 ? 'move' : 'rotate';
                        this.hapticFeedback();
                        return;
                    }
                }
                
                // Mirror detection
                const mirrorStart = {
                    x: this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2,
                    y: this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2
                };
                const mirrorEnd = {
                    x: this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2,
                    y: this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2
                };
                
                const distToMirror = this.distanceToLine(pos, mirrorStart, mirrorEnd);
                if (distToMirror < 2.5 + touchTolerance) {
                    this.isDragging = true;
                    this.dragTarget = 'mirror';
                    
                    const distToCenter = Math.sqrt(
                        Math.pow(pos.x - this.mirror.x, 2) + 
                        Math.pow(pos.y - this.mirror.y, 2)
                    );
                    
                    this.mirrorDragMode = distToCenter < 5 + touchTolerance ? 'move' : 'rotate';
                    this.hapticFeedback();
                }
            }
            
            handleMove(e) {
                if (!this.isDragging) return;
                
                const pos = this.getPointerPos(e);
                const canvas = this.canvas.getBoundingClientRect();
                
                if (this.dragTarget === 'object') {
                    this.object.x = Math.max(this.object.size, 
                        Math.min(this.pxToCm(canvas.width) - this.object.size, pos.x));
                    this.object.y = Math.max(this.object.size, 
                        Math.min(this.pxToCm(canvas.height) - this.object.size, pos.y));
                        
                } else if (this.dragTarget === 'mirror') {
                    if (this.mirrorDragMode === 'move') {
                        this.mirror.x = Math.max(10, 
                            Math.min(this.pxToCm(canvas.width) - 10, pos.x));
                        this.mirror.y = Math.max(10, 
                            Math.min(this.pxToCm(canvas.height) - 10, pos.y));
                    } else {
                        const centerToMouse = Math.atan2(pos.y - this.mirror.y, pos.x - this.mirror.x);
                        this.mirror.angle = centerToMouse;
                        
                        const degrees = Math.round((this.mirror.angle * 180) / Math.PI);
                        const normalizedDegrees = ((degrees % 360) + 360) % 360;
                        document.getElementById('mirrorAngle').value = normalizedDegrees;
                        document.getElementById('angleValue').textContent = normalizedDegrees + '¬∞';
                    }
                    
                } else if (this.dragTarget === 'ruler') {
                    if (this.rulerDragMode === 'move') {
                        this.ruler.x = pos.x;
                        this.ruler.y = pos.y;
                    } else if (this.rulerDragMode === 'rotate') {
                        const centerToMouse = Math.atan2(pos.y - this.ruler.y, pos.x - this.ruler.x);
                        this.ruler.angle = centerToMouse;
                    }
                    
                } else if (this.dragTarget === 'protractor') {
                    if (this.protractorDragMode === 'move') {
                        this.protractor.x = Math.max(this.protractor.radius, 
                            Math.min(this.pxToCm(canvas.width) - this.protractor.radius, pos.x));
                        this.protractor.y = Math.max(this.protractor.radius, 
                            Math.min(this.pxToCm(canvas.height) - this.protractor.radius, pos.y));
                    } else if (this.protractorDragMode === 'rotate') {
                        const centerToMouse = Math.atan2(pos.y - this.protractor.y, pos.x - this.protractor.x);
                        this.protractor.angle = centerToMouse;
                    }
                }
                
                this.lastTouch = pos;
            }
            
            handleEnd() {
                if (this.isDragging) {
                    this.hapticFeedback();
                }
                this.isDragging = false;
                this.dragTarget = null;
                this.rulerDragMode = null;
                this.mirrorDragMode = null;
                this.protractorDragMode = null;
            }
            
            // ... (Include all other methods from the original code with same logic)
            // For brevity, I'm including key methods that are essential for mobile optimization
            
            isObjectInFrontOfMirror() {
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const objectToMirror = {
                    x: this.mirror.x - this.object.x,
                    y: this.mirror.y - this.object.y
                };
                
                const dotProduct = objectToMirror.x * mirrorNormal.x + objectToMirror.y * mirrorNormal.y;
                return dotProduct > 0;
            }
            
            getVirtualImage() {
                if (!this.isObjectInFrontOfMirror()) {
                    return null;
                }
                
                const mirrorNormal = {
                    x: -Math.sin(this.mirror.angle),
                    y: Math.cos(this.mirror.angle)
                };
                
                const toMirror = {
                    x: this.mirror.x - this.object.x,
                    y: this.mirror.y - this.object.y
                };
                
                const normalDist = toMirror.x * mirrorNormal.x + toMirror.y * mirrorNormal.y;
                
                return {
                    x: this.object.x + 2 * normalDist * mirrorNormal.x,
                    y: this.object.y + 2 * normalDist * mirrorNormal.y
                };
            }
            
            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            distanceToRuler(point) {
                const rulerStart = {
                    x: this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2,
                    y: this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2
                };
                const rulerEnd = {
                    x: this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2,
                    y: this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2
                };
                
                return this.distanceToLine(point, rulerStart, rulerEnd);
            }
            
            isNearRulerEnd(point) {
                const endX = this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2;
                const endY = this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2;
                const distToEnd = Math.sqrt(
                    Math.pow(point.x - endX, 2) + Math.pow(point.y - endY, 2)
                );
                return distToEnd < (this.isMobile ? 5 : 3);
            }
            
            animate(currentTime) {
                if (currentTime - this.lastFrameTime >= this.frameInterval) {
                    this.draw();
                    this.lastFrameTime = currentTime;
                }
                this.animationId = requestAnimationFrame((time) => this.animate(time));
            }
            
            draw() {
                // Clear with mobile-optimized performance
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Simplified drawing for mobile
                if (this.isMobile) {
                    this.drawSimplified();
                } else {
                    this.drawFull();
                }
                
                this.updateStatus();
            }
            
            drawSimplified() {
                // Simplified version for mobile performance
                this.drawMirror();
                this.drawObject();
                
                if (this.isObjectInFrontOfMirror()) {
                    this.drawVirtualImage();
                    this.drawRaysSimplified();
                }
                
                if (this.ruler.visible) {
                    this.drawRuler();
                }
                
                if (this.protractor.visible) {
                    this.drawProtractor();
                }
            }
            
            drawFull() {
                // Full version for desktop
                this.drawGrid();
                this.drawMirror();
                this.drawObject();
                
                if (this.isObjectInFrontOfMirror()) {
                    this.drawVirtualImage();
                    this.drawRays();
                }
                
                if (this.ruler.visible) {
                    this.drawRuler();
                }
                
                if (this.protractor.visible) {
                    this.drawProtractor();
                }
            }
            
            // Include simplified versions of drawing methods
            drawGrid() {
                if (this.isMobile) return; // Skip grid on mobile for performance
                
                this.ctx.strokeStyle = 'rgba(100, 116, 139, 0.1)';
                this.ctx.lineWidth = 1;
                
                const canvas = this.canvas.getBoundingClientRect();
                
                for (let x = 0; x < canvas.width; x += this.cmToPx(5)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += this.cmToPx(5)) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawMirror() {
                const startX = this.cmToPx(this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2);
                const startY = this.cmToPx(this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2);
                const endX = this.cmToPx(this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2);
                const endY = this.cmToPx(this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2);
                
                // Simplified mirror for mobile
                if (this.isMobile) {
                    this.ctx.strokeStyle = '#718096';
                    this.ctx.lineWidth = 12;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                    this.ctx.stroke();
                } else {
                    // Full mirror with gradient
                    const gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
                    gradient.addColorStop(0, '#E2E8F0');
                    gradient.addColorStop(0.3, '#CBD5E0');
                    gradient.addColorStop(0.7, '#A0AEC0');
                    gradient.addColorStop(1, '#718096');
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 16;
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                    this.ctx.stroke();
                    
                    this.drawMirrorNotches(startX, startY, endX, endY);
                }
                
                // Mirror edge
                this.ctx.strokeStyle = '#2D3748';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Center handle
                this.ctx.fillStyle = '#667EEA';
                this.ctx.beginPath();
                this.ctx.arc(this.cmToPx(this.mirror.x), this.cmToPx(this.mirror.y), this.isMobile ? 12 : 8, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawMirrorNotches(startX, startY, endX, endY) {
                if (this.isMobile) return; // Skip notches on mobile
                
                const mirrorLength = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const unitX = (endX - startX) / mirrorLength;
                const unitY = (endY - startY) / mirrorLength;
                
                const leftNormalX = -unitY;
                const leftNormalY = unitX;
                
                const notchSpacing = this.cmToPx(2);
                const notchLength = 8;
                const notchCount = Math.floor(mirrorLength / notchSpacing);
                
                this.ctx.strokeStyle = '#2D3748';
                this.ctx.lineWidth = 2;
                
                for (let i = 1; i < notchCount; i++) {
                    const t = i / notchCount;
                    const notchX = startX + t * (endX - startX);
                    const notchY = startY + t * (endY - startY);
                    
                    const notchEndX = notchX + leftNormalX * notchLength;
                    const notchEndY = notchY + leftNormalY * notchLength;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(notchX, notchY);
                    this.ctx.lineTo(notchEndX, notchEndY);
                    this.ctx.stroke();
                }
            }
            
            drawObject() {
                const x = this.cmToPx(this.object.x);
                const y = this.cmToPx(this.object.y);
                const size = this.cmToPx(this.object.size);
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, '#FC8181');
                gradient.addColorStop(1, '#E53E3E');
                
                this.ctx.fillStyle = gradient;
                this.ctx.strokeStyle = '#C53030';
                this.ctx.lineWidth = this.isMobile ? 2 : 3;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(this.object.rotation);
                
                switch(this.object.type) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, 0);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.lineTo(size * 0.2, -size * 0.6);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(size * 0.2, size * 0.6);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-size, -size, size * 2, size * 2);
                        this.ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                        
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(-size, size);
                        this.ctx.lineTo(size, size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'letter_e':
                        const lineWidth = size * 0.15;
                        this.ctx.lineWidth = lineWidth;
                        this.ctx.strokeStyle = '#C53030';
                        this.ctx.fillStyle = gradient;
                        
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, lineWidth, size * 1.6);
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, size * 1.4, lineWidth);
                        this.ctx.fillRect(-size * 0.8, -lineWidth/2, size * 1.2, lineWidth);
                        this.ctx.fillRect(-size * 0.8, size * 0.8 - lineWidth, size * 1.4, lineWidth);
                        break;
                }
                
                this.ctx.restore();
                
                // Center point - larger for mobile
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(x, y, this.isMobile ? 6 : 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawVirtualImage() {
                const virtualPos = this.getVirtualImage();
                if (!virtualPos) return;
                
                const x = this.cmToPx(virtualPos.x);
                const y = this.cmToPx(virtualPos.y);
                const size = this.cmToPx(this.object.size);
                
                this.ctx.setLineDash([this.isMobile ? 8 : 10, this.isMobile ? 8 : 10]);
                this.ctx.strokeStyle = '#667EEA';
                this.ctx.lineWidth = this.isMobile ? 2 : 3;
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.4)');
                gradient.addColorStop(1, 'rgba(102, 126, 234, 0.2)');
                this.ctx.fillStyle = gradient;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(-this.object.rotation);
                
                // Draw same shapes as object but mirrored
                switch(this.object.type) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'arrow':
                        this.ctx.scale(-1, 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(-size, 0);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.lineTo(size * 0.2, -size * 0.6);
                        this.ctx.lineTo(size, 0);
                        this.ctx.lineTo(size * 0.2, size * 0.6);
                        this.ctx.lineTo(size * 0.4, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-size, -size, size * 2, size * 2);
                        this.ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                        
                    case 'triangle':
                        this.ctx.scale(-1, 1);
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -size);
                        this.ctx.lineTo(-size, size);
                        this.ctx.lineTo(size, size);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                        break;
                        
                    case 'letter_e':
                        this.ctx.scale(-1, 1);
                        const lineWidth = size * 0.15;
                        
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, lineWidth, size * 1.6);
                        this.ctx.fillRect(-size * 0.8, -size * 0.8, size * 1.4, lineWidth);
                        this.ctx.fillRect(-size * 0.8, -lineWidth/2, size * 1.2, lineWidth);
                        this.ctx.fillRect(-size * 0.8, size * 0.8 - lineWidth, size * 1.4, lineWidth);
                        break;
                }
                
                this.ctx.restore();
                this.ctx.setLineDash([]);
                
                this.ctx.fillStyle = '#667EEA';
                this.ctx.beginPath();
                this.ctx.arc(x, y, this.isMobile ? 6 : 4, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawRaysSimplified() {
                // Simplified ray drawing for mobile
                if (!this.isObjectInFrontOfMirror()) return;
                
                const mirrorStartX = this.mirror.x - Math.cos(this.mirror.angle) * this.mirror.length / 2;
                const mirrorStartY = this.mirror.y - Math.sin(this.mirror.angle) * this.mirror.length / 2;
                const mirrorEndX = this.mirror.x + Math.cos(this.mirror.angle) * this.mirror.length / 2;
                const mirrorEndY = this.mirror.y + Math.sin(this.mirror.angle) * this.mirror.length / 2;
                
                const virtualPos = this.getVirtualImage();
                const rayAngles = [Math.PI * 0.25, Math.PI * 1.75];
                
                for (let i = 0; i < this.rayCount; i++) {
                    const angle = rayAngles[i];
                    const rayStartX = this.object.x + Math.cos(angle) * this.object.size * 0.8;
                    const rayStartY = this.object.y + Math.sin(angle) * this.object.size * 0.8;
                    
                    const toMirrorX = this.mirror.x - rayStartX;
                    const toMirrorY = this.mirror.y - rayStartY;
                    const length = Math.sqrt(toMirrorX * toMirrorX + toMirrorY * toMirrorY);
                    const dirX = toMirrorX / length;
                    const dirY = toMirrorY / length;
                    
                    const rayEnd = {
                        x: rayStartX + dirX * 120,
                        y: rayStartY + dirY * 120
                    };
                    
                    const intersection = this.lineIntersection(
                        { x: rayStartX, y: rayStartY },
                        rayEnd,
                        { x: mirrorStartX, y: mirrorStartY },
                        { x: mirrorEndX, y: mirrorEndY }
                    );
                    
                    if (intersection) {
                        // Simplified incident ray (no arrow)
                        this.ctx.strokeStyle = '#F39C12';
                        this.ctx.lineWidth = this.isMobile ? 3 : 4;
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.cmToPx(rayStartX), this.cmToPx(rayStartY));
                        this.ctx.lineTo(this.cmToPx(intersection.x), this.cmToPx(intersection.y));
                        this.ctx.stroke();
                        
                        // Simplified reflected ray
                        const mirrorNormal = {
                            x: -Math.sin(this.mirror.angle),
                            y: Math.cos(this.mirror.angle)
                        };
                        const incident = { x: dirX, y: dirY };
                        const reflected = this.calculateReflection(incident, mirrorNormal);
                        
                        const reflectedEndX = intersection.x + reflected.x * 25;
                        const reflectedEndY = intersection.y + reflected.y * 25;
                        
                        this.ctx.strokeStyle = '#27AE60';
                        this.ctx.lineWidth = this.isMobile ? 3 : 4;
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.cmToPx(intersection.x), this.cmToPx(intersection.y));
                        this.ctx.lineTo(this.cmToPx(reflectedEndX), this.cmToPx(reflectedEndY));
                        this.ctx.stroke();
                        
                        // Extensions
                        if (this.showExtensions && virtualPos) {
                            const extensionEndX = virtualPos.x + Math.cos(angle) * this.object.size * 0.8;
                            const extensionEndY = virtualPos.y + Math.sin(angle) * this.object.size * 0.8;
                            
                            this.ctx.strokeStyle = 'rgba(39, 174, 96, 0.6)';
                            this.ctx.lineWidth = 2;
                            this.ctx.setLineDash([this.isMobile ? 8 : 10, this.isMobile ? 8 : 10]);
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.cmToPx(intersection.x), this.cmToPx(intersection.y));
                            this.ctx.lineTo(this.cmToPx(extensionEndX), this.cmToPx(extensionEndY));
                            this.ctx.stroke();
                            this.ctx.setLineDash([]);
                        }
                        
                        // Intersection point - larger for mobile
                        this.ctx.fillStyle = '#F1C40F';
                        this.ctx.beginPath();
                        this.ctx.arc(this.cmToPx(intersection.x), this.cmToPx(intersection.y), this.isMobile ? 8 : 6, 0, 2 * Math.PI);
                        this.ctx.fill();
                    }
                }
            }
            
            drawRays() {
                // Full ray drawing with arrows for desktop
                this.drawRaysSimplified(); // For now, use simplified version
            }
            
            calculateReflection(incident, normal) {
                const dot = incident.x * normal.x + incident.y * normal.y;
                return {
                    x: incident.x - 2 * dot * normal.x,
                    y: incident.y - 2 * dot * normal.y
                };
            }
            
            lineIntersection(p1, p2, p3, p4) {
                const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                if (Math.abs(denom) < 0.001) return null;
                
                const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
                const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;
                
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return null;
            }
            
            drawRuler() {
                const startX = this.cmToPx(this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2);
                const startY = this.cmToPx(this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2);
                const endX = this.cmToPx(this.ruler.x + Math.cos(this.ruler.angle) * this.ruler.length / 2);
                const endY = this.cmToPx(this.ruler.y + Math.sin(this.ruler.angle) * this.ruler.length / 2);
                
                this.ctx.strokeStyle = '#8D6E63';
                this.ctx.lineWidth = this.isMobile ? 10 : 8;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                if (!this.isMobile) {
                    // Detailed ruler markings for desktop only
                    this.ctx.strokeStyle = '#5D4037';
                    this.ctx.lineWidth = 1;
                    this.ctx.font = '10px Arial';
                    this.ctx.fillStyle = '#3E2723';
                    this.ctx.textAlign = 'center';
                    
                    const normalX = -Math.sin(this.ruler.angle);
                    const normalY = Math.cos(this.ruler.angle);
                    
                    for (let i = 0; i <= this.ruler.length; i += 1) {
                        const x = this.cmToPx(this.ruler.x - Math.cos(this.ruler.angle) * this.ruler.length / 2 + Math.cos(this.ruler.angle) * i);
                        const y = this.cmToPx(this.ruler.y - Math.sin(this.ruler.angle) * this.ruler.length / 2 + Math.sin(this.ruler.angle) * i);
                        
                        const markLength = (i % 5 === 0) ? 12 : 8;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, y);
                        this.ctx.lineTo(x + normalX * markLength, y + normalY * markLength);
                        this.ctx.stroke();
                        
                        if (i % 5 === 0) {
                            this.ctx.save();
                            this.ctx.translate(x + normalX * 16, y + normalY * 16);
                            this.ctx.rotate(this.ruler.angle);
                            this.ctx.fillText(i + 'cm', 0, 0);
                            this.ctx.restore();
                        }
                    }
                }
                
                // End handle - larger for mobile
                this.ctx.fillStyle = '#FF5722';
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, this.isMobile ? 10 : 6, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            drawProtractor() {
                const centerX = this.cmToPx(this.protractor.x);
                const centerY = this.cmToPx(this.protractor.y);
                const radius = this.cmToPx(this.protractor.radius);
                
                // Protractor body
                this.ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                this.ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';
                this.ctx.lineWidth = this.isMobile ? 4 : 3;
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI, false);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                if (!this.isMobile) {
                    // Detailed protractor markings for desktop only
                    this.ctx.strokeStyle = 'rgba(255, 140, 0, 0.6)';
                    this.ctx.lineWidth = 1;
                    this.ctx.font = '8px Arial';
                    this.ctx.fillStyle = '#B8860B';
                    this.ctx.textAlign = 'center';
                    
                    for (let angle = 0; angle <= 180; angle += 10) {
                        const radian = (angle * Math.PI) / 180 + this.protractor.angle;
                        const lineLength = (angle % 30 === 0) ? radius * 0.8 : radius * 0.9;
                        
                        const startX = centerX + Math.cos(radian) * lineLength;
                        const startY = centerY + Math.sin(radian) * lineLength;
                        const endX = centerX + Math.cos(radian) * radius;
                        const endY = centerY + Math.sin(radian) * radius;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(startX, startY);
                        this.ctx.lineTo(endX, endY);
                        this.ctx.stroke();
                        
                        if (angle % 30 === 0) {
                            const textX = centerX + Math.cos(radian) * (radius * 0.7);
                            const textY = centerY + Math.sin(radian) * (radius * 0.7);
                            
                            this.ctx.save();
                            this.ctx.translate(textX, textY);
                            this.ctx.rotate(radian - Math.PI/2);
                            this.ctx.fillText(angle + '¬∞', 0, 0);
                            this.ctx.restore();
                        }
                    }
                }
                
                // Center point - larger for mobile
                this.ctx.fillStyle = '#FF8C00';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, this.isMobile ? 10 : 6, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Rotation handle - larger for mobile
                const handleX = centerX + Math.cos(this.protractor.angle + Math.PI) * radius * 0.8;
                const handleY = centerY + Math.sin(this.protractor.angle + Math.PI) * radius * 0.8;
                
                this.ctx.fillStyle = '#FF4500';
                this.ctx.beginPath();
                this.ctx.arc(handleX, handleY, this.isMobile ? 12 : 8, 0, 2 * Math.PI);
                this.ctx.fill();
            }
            
            updateStatus() {
                if (this.isObjectInFrontOfMirror()) {
                    document.getElementById('systemStatus').textContent = 'Normal';
                    document.getElementById('systemStatus').className = 'status-value';
                    document.getElementById('imageStatus').textContent = 'Olu≈üuyor';
                    document.getElementById('imageStatus').className = 'status-value';
                    
                    const virtualPos = this.getVirtualImage();
                    const realDistance = Math.sqrt(
                        Math.pow(this.mirror.x - this.object.x, 2) + 
                        Math.pow(this.mirror.y - this.object.y, 2)
                    );
                    const virtualDistance = Math.sqrt(
                        Math.pow(this.mirror.x - virtualPos.x, 2) + 
                        Math.pow(this.mirror.y - virtualPos.y, 2)
                    );
                    
                    document.getElementById('realDistance').textContent = realDistance.toFixed(1) + ' cm';
                    document.getElementById('virtualDistance').textContent = virtualDistance.toFixed(1) + ' cm';
                    
                } else {
                    document.getElementById('systemStatus').textContent = 'Uyarƒ±';
                    document.getElementById('systemStatus').className = 'status-warning';
                    document.getElementById('imageStatus').textContent = 'Olu≈ümuyor';
                    document.getElementById('imageStatus').className = 'status-warning';
                    
                    document.getElementById('realDistance').textContent = '√ñl√ß√ºlemiyor';
                    document.getElementById('virtualDistance').textContent = 'Yok';
                }
            }
            
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }
        
        let simulation;
        let controlsVisible = true;
        let infoVisible = true;
        
        function toggleControls() {
            controlsVisible = !controlsVisible;
            const panel = document.getElementById('controlsPanel');
            
            if (controlsVisible) {
                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
            
            // Haptic feedback
            if (navigator.vibrate && simulation.isMobile) {
                navigator.vibrate(20);
            }
        }
        
        function toggleInfo() {
            infoVisible = !infoVisible;
            const panel = document.getElementById('infoPanel');
            
            if (infoVisible) {
                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
            
            // Haptic feedback
            if (navigator.vibrate && simulation.isMobile) {
                navigator.vibrate(20);
            }
        }
        
        function toggleExtensions() {
            simulation.showExtensions = !simulation.showExtensions;
            const btn = document.getElementById('showExtensions');
            btn.textContent = 'Uzantƒ±lar: ' + (simulation.showExtensions ? 'A√áIK' : 'KAPALI');
            btn.className = simulation.showExtensions ? 'active' : '';
            simulation.hapticFeedback();
        }
        
        function toggleRuler() {
            simulation.ruler.visible = !simulation.ruler.visible;
            const btn = document.getElementById('showRuler');
            btn.textContent = 'Cetvel: ' + (simulation.ruler.visible ? 'A√áIK' : 'KAPALI');
            btn.className = simulation.ruler.visible ? 'active' : '';
            simulation.hapticFeedback();
        }
        
        function toggleProtractor() {
            simulation.protractor.visible = !simulation.protractor.visible;
            const btn = document.getElementById('showProtractor');
            btn.textContent = 'A√ßƒ± √ñl√ßer: ' + (simulation.protractor.visible ? 'A√áIK' : 'KAPALI');
            btn.className = simulation.protractor.visible ? 'active' : '';
            simulation.hapticFeedback();
        }
        
        // Initialize simulation
        window.addEventListener('load', () => {
            simulation = new MobileOptimizedMirrorSimulation();
            
            // Hide panels initially on small screens
            if (window.innerWidth < 768) {
                setTimeout(() => {
                    toggleControls();
                    toggleInfo();
                }, 3000); // Auto-hide after 3 seconds
            }
        });
        
        // Handle page visibility changes to optimize performance
        document.addEventListener('visibilitychange', () => {
            if (simulation) {
                if (document.hidden) {
                    // Pause animation when page is hidden
                    simulation.destroy();
                } else {
                    // Resume animation when page becomes visible
                    simulation.animate();
                }
            }
        });
        
        // Handle memory warnings on mobile
        if ('memory' in performance) {
            setInterval(() => {
                if (performance.memory.usedJSHeapSize > 50000000) { // 50MB
                    console.warn('High memory usage detected, consider optimizations');
                }
            }, 10000);
        }
    </script>
</body>
</html>
