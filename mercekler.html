<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mercekler</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --panel-bg: rgba(20, 24, 32, 0.95);
            --accent-color: #00f2fe; 
            --text-color: #e0e0e0;
        }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color); color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex; flex-direction: column; 
            height: 100vh; height: 100dvh; 
            overflow: hidden; touch-action: none;
        }
        #top-bar {
            display: flex; flex-wrap: wrap; gap: 8px; padding: 10px 15px;
            background: var(--panel-bg); width: 100%; box-sizing: border-box;
            align-items: center; justify-content: center;
            border-bottom: 1px solid #333; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 10; flex-shrink: 0; 
        }
        .control-group { display: flex; gap: 6px; align-items: center; padding: 5px 10px; background: rgba(255,255,255,0.05); border-radius: 8px; }
        .separator { width: 1px; height: 30px; background: #444; margin: 0 2px; }
        
        button {
            padding: 6px 10px; font-size: 13px; font-weight: 600; cursor: pointer;
            background-color: transparent; color: #888;
            border: 1px solid transparent; border-radius: 6px; transition: 0.3s;
        }
        button:hover { color: var(--text-color); background: rgba(255,255,255,0.1); }
        button.mode-btn.active { background-color: var(--accent-color); color: #000; box-shadow: 0 0 10px rgba(0, 242, 254, 0.3); }
        button.lens-btn.active { border-color: var(--accent-color); color: var(--accent-color); }
        button.shape-btn.active { background-color: rgba(57, 255, 20, 0.2); color: #39ff14; border-color: #39ff14; }

        label { font-size: 12px; font-weight: 600; color: #aaa; cursor: pointer; display: flex; align-items: center; gap: 4px; white-space: nowrap;}
        input[type="range"] { cursor: pointer; width: 70px; accent-color: var(--accent-color); }
        input[type="checkbox"] { accent-color: var(--accent-color); cursor: pointer; margin: 0; }
        
        #canvas-wrapper { flex: 1; position: relative; width: 100%; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: crosshair; background-color: #05070a; background-image: linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px); background-size: 50px 50px; }

        #info-overlay {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(12, 16, 22, 0.85); padding: 8px 15px; border-radius: 8px;
            border: 1px solid #333; border-left: 4px solid var(--accent-color);
            pointer-events: none; user-select: none; backdrop-filter: blur(8px); 
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); font-size: 13px; z-index: 5;
            display: flex; align-items: center; gap: 12px; flex-wrap: wrap; max-width: calc(100% - 40px); 
        }
        .info-section { display: flex; align-items: center; gap: 6px; }
        .info-divider { width: 1px; height: 14px; background: #444; }
        
        body.mode-isin #shape-controls { display: none; }

        @media (max-width: 1000px) {
            #info-overlay { bottom: 10px; left: 10px; right: 10px; font-size: 11px; padding: 8px 10px; gap: 8px; }
            .separator { display: none; }
            #top-bar { padding: 5px; gap: 4px; justify-content: flex-start; overflow-x: auto; }
            .control-group { padding: 4px 6px; flex-shrink: 0; }
        }

        .hl { font-weight: bold; color: var(--accent-color); }
        .hl-obj { font-weight: bold; color: #39ff14; }
        .hl-img { font-weight: bold; color: #ffbd00; }
    </style>
</head>
<body class="mode-isin">

    <div id="top-bar">
        <div class="control-group">
            <button id="btnModeIsin" class="mode-btn active">I≈üƒ±n Modu üî¶</button>
            <button id="btnModeGoruntu" class="mode-btn">G√∂r√ºnt√º Modu üïØÔ∏è</button>
        </div>
        
        <div id="shape-controls" class="control-group" style="border-color: #39ff14;">
            <button id="btnShapeArrow" class="shape-btn active">Ok ‚¨ÜÔ∏è</button>
            <button id="btnShapeTriangle" class="shape-btn">√ú√ßgen üî∫</button>
            <button id="btnShapeF" class="shape-btn">F Harfi ‚íª</button>
        </div>

        <div class="separator"></div>
        <div class="control-group">
            <button id="btnInce" class="lens-btn active">ƒ∞nce Kenarlƒ± (Yakƒ±nsak) Mercek</button>
            <button id="btnKalin" class="lens-btn">Kalƒ±n Kenarlƒ± (Iraksak) Mercek</button>
        </div>
        <div class="separator"></div>
        <div class="control-group">
             <label><input type="checkbox" id="checkAxis"> Asal Eksen</label>
             <label><input type="checkbox" id="checkO"> Optik Merkez</label>
             <label><input type="checkbox" id="checkF"> Odak noktasƒ±</label>
             <label><input type="checkbox" id="check2F"> 2F Noktasƒ±</label>
        </div>
        <div class="control-group">
             <label><input type="checkbox" id="checkRuler" checked> Cetvel</label>
        </div>
        <div class="control-group" style="margin-left:auto;">
            <label for="sliderF">Odak (f):<span id="valF" style="color:var(--accent-color); width:25px; text-align:center;">150</span></label>
            <input type="range" id="sliderF" min="100" max="250" value="150" step="10">
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="simCanvas"></canvas>
        <div id="info-overlay">Y√ºkleniyor...</div>
    </div>

<script>
    const wrapper = document.getElementById('canvas-wrapper');
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const infoOverlay = document.getElementById('info-overlay');
    
    const btnModeIsin = document.getElementById('btnModeIsin');
    const btnModeGoruntu = document.getElementById('btnModeGoruntu');
    const btnInce = document.getElementById('btnInce');
    const btnKalin = document.getElementById('btnKalin');
    
    const btnShapeArrow = document.getElementById('btnShapeArrow');
    const btnShapeTriangle = document.getElementById('btnShapeTriangle');
    const btnShapeF = document.getElementById('btnShapeF');

    const checkAxis = document.getElementById('checkAxis');
    const checkO = document.getElementById('checkO');
    const checkF = document.getElementById('checkF');
    const check2F = document.getElementById('check2F');
    const checkRuler = document.getElementById('checkRuler');
    const sliderF = document.getElementById('sliderF');
    const valF = document.getElementById('valF');

    const C_ACCENT = '#00f2fe';
    const C_LASER = '#ff0055';
    const C_OBJ = '#39ff14';
    const C_IMG = '#ffbd00';

    let width, height;
    let currentMode = 'isin';
    let lensType = 'ince'; 
    let currentShape = 'arrow'; 
    let F_val = 150; 
    
    let showAxis = false; let showO = false; let showF = false; let show2F = false;
    let showRuler = true;
    
    let laser = { x: 100, y: 300, angle: 0, isDraggingBody: false, isDraggingTip: false };
    let obj = { x: 150, h: 80, isDragging: false }; 
    let ruler = { x: -1000, y: -1000, w: 400, h: 40, isDragging: false, offX: 0, offY: 0 }; 

    const shapesDefinition = {
        arrow: [{x1:0, y1:0, x2:0, y2:-80, isTip: true, hasArrowHead: true}],
        triangle: [{x1:0, y1:0, x2:60, y2:0}, {x1:0, y1:0, x2:30, y2:-70, isTip: true}, {x1:60, y1:0, x2:30, y2:-70}],
        letterF: [{x1:0, y1:0, x2:0, y2:-80, isTip: true}, {x1:0, y1:-80, x2:40, y2:-80}, {x1:0, y1:-40, x2:30, y2:-40}]
    };

    function resize() {
        width = wrapper.clientWidth; height = wrapper.clientHeight;
        canvas.width = width; canvas.height = height;
        
        if (laser.y > height) laser.y = height / 2 + 50; 
        
        // Cetvel sƒ±nƒ±r kontrol√º
        if (ruler.x === -1000) { 
            ruler.x = width / 2 - 200; ruler.y = height - 100; 
        } else {
            // Ekran k√º√ß√ºld√ºƒü√ºnde cetvel dƒ±≈üarƒ±da kalmasƒ±n
            if (ruler.y > height - ruler.h - 10) ruler.y = height - ruler.h - 10;
            if (ruler.x > width - 50) ruler.x = width - 200;
        }
        draw();
    }
    window.addEventListener('resize', resize);

    // --- MOD VE D√úƒûME ƒ∞≈ûLEMLERƒ∞ ---
    btnModeIsin.onclick = () => setMode('isin');
    btnModeGoruntu.onclick = () => setMode('goruntu');
    btnInce.onclick = () => setLens('ince');
    btnKalin.onclick = () => setLens('kalin');
    
    btnShapeArrow.onclick = () => setShape('arrow');
    btnShapeTriangle.onclick = () => setShape('triangle');
    btnShapeF.onclick = () => setShape('letterF');

    checkAxis.onchange = (e) => { showAxis = e.target.checked; draw(); };
    checkO.onchange = (e) => { showO = e.target.checked; draw(); };
    checkF.onchange = (e) => { showF = e.target.checked; draw(); };
    check2F.onchange = (e) => { show2F = e.target.checked; draw(); };
    checkRuler.onchange = (e) => { showRuler = e.target.checked; draw(); };
    
    sliderF.oninput = (e) => { F_val = parseInt(e.target.value); valF.innerText = F_val; draw(); };

    function setMode(mode) {
        currentMode = mode;
        document.body.className = 'mode-' + mode; 
        btnModeIsin.classList.toggle('active', mode === 'isin');
        btnModeGoruntu.classList.toggle('active', mode === 'goruntu');
        
        // √ñNEMLƒ∞ D√úZELTME: Mod deƒüi≈ütiƒüinde √ºst men√ºn√ºn y√ºksekliƒüi deƒüi≈üebilir.
        // Canvas alanƒ±nƒ± yeniden hesaplamasƒ± i√ßin resize fonksiyonunu √ßaƒüƒ±rƒ±yoruz.
        setTimeout(resize, 30); 
    }
    
    function setLens(type) {
        lensType = type;
        btnInce.classList.toggle('active', type === 'ince');
        btnKalin.classList.toggle('active', type === 'kalin');
        draw();
    }
    
    function setShape(shape) {
        currentShape = shape;
        btnShapeArrow.classList.toggle('active', shape === 'arrow');
        btnShapeTriangle.classList.toggle('active', shape === 'triangle');
        btnShapeF.classList.toggle('active', shape === 'letterF');
        draw();
    }

    // --- ETKƒ∞LE≈ûƒ∞M Y√ñNETƒ∞Mƒ∞ ---
    function handleStart(e) {
        if(e.type === 'touchstart') e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mx = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left; 
        const my = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const centerY = height / 2;

        if (showRuler && mx >= ruler.x && mx <= ruler.x + ruler.w && my >= ruler.y && my <= ruler.y + ruler.h) {
            ruler.isDragging = true; ruler.offX = mx - ruler.x; ruler.offY = my - ruler.y; return;
        }

        if (currentMode === 'isin') {
            let tipX = laser.x + Math.cos(laser.angle) * 55; let tipY = laser.y + Math.sin(laser.angle) * 55;
            if (Math.hypot(mx - tipX, my - tipY) < 35) { laser.isDraggingTip = true; return; }
            if (Math.hypot(mx - laser.x, my - laser.y) < 50) { laser.isDraggingBody = true; return; }
        } else {
            if (Math.abs(mx - obj.x) < 50 && my > centerY - 100 && my < centerY + 20) {
                obj.isDragging = true; return;
            }
        }
    }

    function handleMove(e) {
        if(e.type === 'touchmove') e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mx = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left; 
        const my = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const centerY = height / 2;

        if (ruler.isDragging) { ruler.x = mx - ruler.offX; ruler.y = my - ruler.offY; draw(); canvas.style.cursor = 'grabbing'; return; }
        if (laser.isDraggingBody) { laser.x = mx; laser.y = my; draw(); canvas.style.cursor = 'grabbing'; return; }
        if (laser.isDraggingTip) { laser.angle = Math.atan2(my - laser.y, mx - laser.x); draw(); canvas.style.cursor = 'grabbing'; return; }
        if (obj.isDragging) {
            let limitX = width / 2 + (width > 600 ? 80 : 30); 
            obj.x = Math.min(mx, limitX); draw(); canvas.style.cursor = 'grabbing'; return;
        }

        let isHovering = false;
        if (showRuler && mx >= ruler.x && mx <= ruler.x + ruler.w && my >= ruler.y && my <= ruler.y + ruler.h) isHovering = true;
        
        if (!isHovering) {
            if (currentMode === 'isin') {
                let tipX = laser.x + Math.cos(laser.angle) * 55; let tipY = laser.y + Math.sin(laser.angle) * 55;
                if (Math.hypot(mx - tipX, my - tipY) < 35 || Math.hypot(mx - laser.x, my - laser.y) < 50) isHovering = true;
            } else {
                if (Math.abs(mx - obj.x) < 50 && my > centerY - 100 && my < centerY + 20) isHovering = true;
            }
        }
        canvas.style.cursor = isHovering ? 'grab' : 'crosshair';
    }

    const stopDrag = () => { ruler.isDragging = false; laser.isDraggingBody = false; laser.isDraggingTip = false; obj.isDragging = false; canvas.style.cursor = 'crosshair'; };

    canvas.addEventListener('mousedown', handleStart); canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', stopDrag); canvas.addEventListener('mouseleave', stopDrag);
    canvas.addEventListener('touchstart', handleStart, {passive: false}); canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', stopDrag);

    // --- √áƒ∞Zƒ∞M MOTORU ---
    function draw() {
        ctx.clearRect(0, 0, width, height);
        const centerY = height / 2;
        const centerX = width > 600 ? width / 2 + 100 : width / 2 + 50; 
        const O_x = centerX; 
        
        drawAxis(centerY, O_x);
        drawLensBody(centerY, O_x); 

        if (currentMode === 'isin') {
            drawModernLaser();
            calculateAndDrawRefraction(O_x, centerY);
            updateInfoRayMode();
        } else {
            drawComplexShapeMode(centerY, O_x);
        }
        
        drawSymmetricPoints(centerY, O_x);
        drawPortableRuler();
    }

    function drawAxis(centerY, O_x) {
        if (!showAxis) return; 
        ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(width, centerY);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; ctx.lineWidth = 1.5; ctx.stroke();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 2;
        for (let x = O_x; x > 0; x -= 50) { ctx.beginPath(); ctx.moveTo(x, centerY - 6); ctx.lineTo(x, centerY + 6); ctx.stroke(); }
        for (let x = O_x; x < width; x += 50) { ctx.beginPath(); ctx.moveTo(x, centerY - 6); ctx.lineTo(x, centerY + 6); ctx.stroke(); }
    }
    
    function drawSymmetricPoints(centerY, O_x) {
        ctx.font = 'bold 12px Segoe UI'; ctx.textAlign = 'center';
        const drawPoint = (x, label) => {
            ctx.beginPath(); ctx.arc(x, centerY, 5, 0, Math.PI*2); 
            ctx.fillStyle = '#ffffff'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#000000'; ctx.stroke();
            ctx.fillStyle = C_ACCENT; ctx.shadowBlur = 4; ctx.shadowColor = '#000000';
            ctx.fillText(label, x, centerY + 24); ctx.shadowBlur = 0; 
        };
        
        if (showO) drawPoint(O_x, 'Optik Merkez'); 
        if (showF) { drawPoint(O_x - F_val, 'F'); drawPoint(O_x + F_val, 'F'); }
        if (show2F) { drawPoint(O_x - 2*F_val, '2F'); drawPoint(O_x + 2*F_val, '2F'); }
    }
    
    function drawLensBody(centerY, O_x) {
        let lensHeight = 160; let lensWidth = 30;
        ctx.beginPath();
        if (lensType === 'ince') {
            ctx.moveTo(O_x, centerY - lensHeight);
            ctx.quadraticCurveTo(O_x + lensWidth, centerY, O_x, centerY + lensHeight);
            ctx.quadraticCurveTo(O_x - lensWidth, centerY, O_x, centerY - lensHeight);
        } else {
            ctx.moveTo(O_x - lensWidth/2, centerY - lensHeight); ctx.lineTo(O_x + lensWidth/2, centerY - lensHeight);
            ctx.quadraticCurveTo(O_x + 5, centerY, O_x + lensWidth/2, centerY + lensHeight);
            ctx.lineTo(O_x - lensWidth/2, centerY + lensHeight); ctx.quadraticCurveTo(O_x - 5, centerY, O_x - lensWidth/2, centerY - lensHeight);
        }
        ctx.fillStyle = 'rgba(0, 242, 254, 0.15)'; ctx.fill();
        ctx.strokeStyle = C_ACCENT; ctx.lineWidth = 2; ctx.lineCap = 'round';
        ctx.shadowBlur = 15; ctx.shadowColor = C_ACCENT; ctx.stroke(); ctx.shadowBlur = 0;
        
        ctx.beginPath(); ctx.moveTo(O_x, centerY - lensHeight - 20); ctx.lineTo(O_x, centerY + lensHeight + 20);
        ctx.strokeStyle = 'rgba(0, 242, 254, 0.3)'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
    }

    function drawPortableRuler() {
        if (!showRuler) return;
        ctx.save(); ctx.translate(ruler.x, ruler.y);
        ctx.fillStyle = 'rgba(0, 242, 254, 0.1)'; ctx.strokeStyle = 'rgba(0, 242, 254, 0.6)'; ctx.lineWidth = 1;
        ctx.beginPath(); if (ctx.roundRect) ctx.roundRect(0, 0, ruler.w, ruler.h, 6); else ctx.rect(0, 0, ruler.w, ruler.h);
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = C_ACCENT; ctx.font = '10px Segoe UI'; ctx.textAlign = 'center';
        for (let i = 0; i <= ruler.w; i += 10) {
            let isMajor = (i % 50 === 0); let tickH = isMajor ? 12 : 6;
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, tickH); ctx.stroke();
            if (isMajor) ctx.fillText(i, i, tickH + 12);
        }
        ctx.restore();
    }
    
    function drawModernLaser() {
        ctx.save(); ctx.translate(laser.x, laser.y); ctx.rotate(laser.angle);
        let grad = ctx.createLinearGradient(-40, -15, 40, 15); 
        grad.addColorStop(0, '#222'); grad.addColorStop(0.5, '#444'); grad.addColorStop(1, '#222');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(-40, -10); ctx.lineTo(25, -10); ctx.lineTo(40, -5); ctx.lineTo(40, 5); ctx.lineTo(25, 10); ctx.lineTo(-40, 10); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = C_ACCENT; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-20, -10); ctx.lineTo(-20, 10); ctx.moveTo(10, -10); ctx.lineTo(10, 10); ctx.stroke();
        ctx.shadowBlur = 20; ctx.shadowColor = C_LASER; ctx.fillStyle = laser.isDraggingTip ? '#fff' : C_LASER; ctx.beginPath(); ctx.arc(45, 0, 6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = C_LASER; ctx.beginPath(); ctx.arc(48, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }
    
    function calculateAndDrawRefraction(O_x, centerY) {
        let dx = Math.cos(laser.angle), dy = Math.sin(laser.angle);
        let startX = laser.x + 48 * dx, startY = laser.y + 48 * dy;
        
        if (dx <= 0.001) { ctx.strokeStyle = C_LASER; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(startX + dx*2000, startY + dy*2000); ctx.stroke(); return; }

        let t = (O_x - startX) / dx; let y_hit = startY + t * dy;
        let isHit = (t > 0) && (Math.abs(y_hit - centerY) <= 160); 
        
        ctx.strokeStyle = C_LASER; ctx.lineWidth = 3; ctx.shadowBlur = 20; ctx.shadowColor = C_LASER;
        ctx.beginPath(); ctx.moveTo(startX, startY);

        if (isHit) {
            ctx.lineTo(O_x, y_hit); ctx.stroke(); ctx.shadowBlur = 0;
            let y_i = y_hit - centerY; 
            let m1 = dy / dx;          
            let Power = lensType === 'ince' ? (1/F_val) : (-1/F_val);
            let m2 = m1 - (y_i * Power); 
            let angle2 = Math.atan(m2);
            let rx = Math.cos(angle2); let ry = Math.sin(angle2);

            ctx.strokeStyle = C_LASER; ctx.lineWidth = 3; ctx.shadowBlur = 20; ctx.shadowColor = C_LASER;
            ctx.beginPath(); ctx.moveTo(O_x, y_hit); ctx.lineTo(O_x + rx*3000, y_hit + ry*3000); ctx.stroke(); ctx.shadowBlur = 0;
            
            if (lensType === 'kalin' || (lensType === 'ince' && O_x - startX < F_val && dy/dx !== m2)) {
                 drawDashedLine(O_x, y_hit, O_x - rx*2000, y_hit - ry*2000, 'rgba(255, 0, 85, 0.4)');
            }
        } else { ctx.lineTo(startX + dx*3000, startY + dy*3000); ctx.stroke(); ctx.shadowBlur = 0; }
    }

    function calculateImagePointLens(objX, objY, centerY, O_x) {
        let d_o = O_x - objX; 
        let f_i≈üaretli = lensType === 'ince' ? F_val : -F_val;
        if (Math.abs(d_o - f_i≈üaretli) < 0.5 && lensType === 'ince') return null;
        let d_i = (d_o * f_i≈üaretli) / (d_o - f_i≈üaretli);
        let m = -d_i / d_o; 
        let imgX = O_x + d_i; 
        let h_o = centerY - objY; 
        let h_i = h_o * m; 
        let imgY = centerY - h_i;
        return { x: imgX, y: imgY, d_i: d_i, m: m };
    }

    function drawComplexShapeMode(centerY, O_x) {
        let shapeSegments = shapesDefinition[currentShape];
        let tipPointObj = null; let mainImageInfo = null; 

        ctx.strokeStyle = C_OBJ; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath();
        let objArrowHeads = [];
        shapeSegments.forEach(seg => {
            let absX1 = obj.x + seg.x1; let absY1 = centerY + seg.y1;
            let absX2 = obj.x + seg.x2; let absY2 = centerY + seg.y2;
            ctx.moveTo(absX1, absY1); ctx.lineTo(absX2, absY2);
            if(seg.isTip && seg.hasArrowHead) objArrowHeads.push({x1: absX1, y1: absY1, x2: absX2, y2: absY2});
            if(seg.isTip) tipPointObj = {x: absX2, y: absY2}; 
        });
        ctx.stroke(); 
        
        objArrowHeads.forEach(ah => { ctx.fillStyle = C_OBJ; ctx.strokeStyle = C_OBJ; drawArrowHead(ah.x1, ah.y1, ah.x2, ah.y2); });
        ctx.fillStyle = C_OBJ; ctx.font = 'bold 14px Segoe UI'; 
        ctx.fillText(currentShape === 'arrow' ? 'Cisim' : '', obj.x - 20, centerY + 30);

        let isVirtual = false; let imgArrowHeads = [];
        ctx.beginPath();
        shapeSegments.forEach(seg => {
            let p1_img = calculateImagePointLens(obj.x + seg.x1, centerY + seg.y1, centerY, O_x);
            let p2_img = calculateImagePointLens(obj.x + seg.x2, centerY + seg.y2, centerY, O_x);
            if (p1_img && p2_img) {
                ctx.moveTo(p1_img.x, p1_img.y); ctx.lineTo(p2_img.x, p2_img.y);
                if (p1_img.d_i < 0) isVirtual = true; 
                if (seg.isTip) { mainImageInfo = p2_img; if(seg.hasArrowHead) imgArrowHeads.push({x1: p1_img.x, y1: p1_img.y, x2: p2_img.x, y2: p2_img.y}); }
            }
        });

        ctx.strokeStyle = C_IMG; if (isVirtual) ctx.setLineDash([8, 5]); 
        ctx.stroke(); ctx.setLineDash([]); 
        imgArrowHeads.forEach(ah => { ctx.fillStyle = C_IMG; ctx.strokeStyle = C_IMG; drawArrowHead(ah.x1, ah.y1, ah.x2, ah.y2); });

        if (tipPointObj && mainImageInfo) { drawLensPrincipalRays(tipPointObj.x, tipPointObj.y, mainImageInfo.x, mainImageInfo.y, centerY, O_x); }

        let d_o_main = O_x - obj.x;
        updateInfoImageMode(d_o_main, mainImageInfo ? mainImageInfo.d_i : null, mainImageInfo ? mainImageInfo.m : null);
    }
    
    function drawArrowHead(x1, y1, x2, y2) {
        let angle = Math.atan2(y2-y1, x2-x1); let head = 14;
        ctx.save(); ctx.beginPath(); ctx.moveTo(x2, y2);
        ctx.lineTo(x2-head*Math.cos(angle-Math.PI/6), y2-head*Math.sin(angle-Math.PI/6));
        ctx.lineTo(x2-head*Math.cos(angle+Math.PI/6), y2-head*Math.sin(angle+Math.PI/6));
        ctx.closePath(); ctx.fill(); ctx.restore();
    }

    function drawLensPrincipalRays(objX, objY, imgX, imgY, centerY, O_x) {
        ctx.lineWidth = 2; 
        ctx.strokeStyle = 'rgba(255, 50, 100, 0.5)'; ctx.beginPath(); ctx.moveTo(objX, objY); ctx.lineTo(O_x, objY); ctx.stroke();
        let F_sag = O_x + F_val; let F_sol = O_x - F_val;

        if (lensType === 'ince') {
             let m = (centerY - objY) / (F_sag - O_x);
             ctx.beginPath(); ctx.moveTo(O_x, objY); ctx.lineTo(O_x + 1000, objY + 1000*m); ctx.stroke();
             if(imgX < O_x) drawDashedLine(O_x, objY, imgX, imgY, 'rgba(255, 50, 100, 0.3)'); 
        } else {
             let m = (objY - centerY) / (O_x - F_sol); 
             ctx.beginPath(); ctx.moveTo(O_x, objY); ctx.lineTo(O_x + 1000, objY + 1000*m); ctx.stroke();
             drawDashedLine(O_x, objY, F_sol, centerY, 'rgba(255, 50, 100, 0.3)'); 
        }
        ctx.strokeStyle = 'rgba(0, 242, 254, 0.5)'; ctx.beginPath(); ctx.moveTo(objX, objY); ctx.lineTo(O_x, centerY); 
        let d_o = O_x - objX; let h_o = centerY - objY; let m_center = h_o / -d_o;
        ctx.lineTo(O_x + 1000, centerY + 1000*m_center); ctx.stroke();
        if (imgX < O_x) drawDashedLine(O_x, centerY, imgX, imgY, 'rgba(0, 242, 254, 0.3)'); 
    }

    function drawDashedLine(x1, y1, x2, y2, color) {
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.setLineDash([8, 8]); ctx.stroke(); ctx.setLineDash([]);
    }

    function updateInfoRayMode() {
        infoOverlay.innerHTML = `<div class="info-section">üî¨ <span class="hl">Kƒ±rƒ±lma Modu</span></div><div class="info-divider"></div><div class="info-section">Lazerin g√∂vdesini s√ºr√ºkleyin, ucundan a√ßƒ±sƒ±nƒ± ayarlayƒ±n.</div>`;
    }
    
    function updateInfoImageMode(d_o, d_i, m) {
        if (d_i === null || isNaN(d_i)) { 
            infoOverlay.innerHTML = `<div class="info-section">üî¨ <span class="hl">G√∂r√ºnt√º Modu</span></div><div class="info-divider"></div><div class="info-section"><span class="hl-obj">Cisim Odakta:</span> I≈üƒ±nlar paralel kƒ±rƒ±lƒ±r, g√∂r√ºnt√º sonsuzda.</div>`; return; 
        }
        let type = d_i > 0 ? "Ger√ßek (Kar≈üƒ±da)" : "Sanal (Cisimle Aynƒ± Tarafta)";
        let orient = m < 0 ? "Ters" : "D√ºz";
        let size = Math.abs(m) > 1.05 ? "B√ºy√ºk" : (Math.abs(m) < 0.95 ? "K√º√ß√ºk" : "E≈üit");
        infoOverlay.innerHTML = `
            <div class="info-section">üî¨ <span class="hl">Merceklerde G√∂r√ºnt√º</span></div><div class="info-divider"></div>
            <div class="info-section">üìè <span class="hl-obj">Cisim:</span> ${Math.round(d_o)}br</div><div class="info-divider"></div>
            <div class="info-section">üìè <span class="hl-img">G√∂r√ºnt√º:</span> ${Math.round(Math.abs(d_i))}br</div><div class="info-divider"></div>
            <div class="info-section">üîé ${Math.abs(m).toFixed(2)}x B√ºy√ºtme</div><div class="info-divider"></div>
            <div class="info-section">üìå ${type}, ${orient}, ${size}</div>
        `;
    }

    setTimeout(resize, 100);
</script>
</body>
</html>
